{"./":{"url":"./","title":"Introduction","keywords":"","body":"供个人JavaScript学习 "},"基础/基础.html":{"url":"基础/基础.html","title":"基础","keywords":"","body":"基础 "},"基础/变量.html":{"url":"基础/变量.html","title":"变量","keywords":"","body":"变量 字符串 数字 布尔 数组 对象 Undefined 和 null // 未定义类型 var x ; // 数字类型 var y = 5; // 字符串类型 双引号或者单引号均可 var k = 'john'; var a = 123e5; // 布尔类型 var b = true; // 数组类型 var cars = []; cars[0] = \"Saab\"; cars[2] = \"Volvo\"; // 对象类型 var person = {name:\"veng\",age:22}; var name = person.name; var name2 = person[\"name\"]; "},"基础/字符串.html":{"url":"基础/字符串.html","title":"字符串","keywords":"","body":"字符串 JavaScript的字符串就是用''或\"\"括起来的字符表示。 如果'本身也是一个字符，那就可以用\"\"括起来，比如\"I'm OK\"包含的字符是I，'，m，空格，O，K这6个字符。 如果字符串内部既包含'又包含\"怎么办？可以用转义字符\\来标识，比如： var hello = \"I\\'m \\\"OK\\\"\"; hello => I'm \"OK\" ASCII字符可以以\\x##形式的十六进制表示，例如： var a = \"\\x61\"; a => a 61是97的16进制表示 还可以用\\u####表示一个Unicode字符： // 貌似是 UTF-16码位 var b = \"\\u4F60\\u597D\"; b => 你好 多行字符串，由于多行字符串用\\n写起来比较费事，所以最新的ES6标准新增了一种多行字符串的表示方法，用反引号 ` 表示 var c = `first second third`; c => first second third 模板字符串，跟其他语言一样，直接用 + 号连接。 var d = \"world\"; var e = \"hello \"+d; e => hello world 如果有很多变量需要连接，用+号就比较麻烦。ES6新增了一种模板字符串，表示方法和上面的多行字符串一样，用反引号`，但是它会自动替换字符串中的变量： var d = \"world\"; // 注意这里用反引号 var f = `hello ${d}`; f => hello world 字符串的常见方法： var h = \"hello world\"; // 获取字符串的长度 var length = h.length; // 字符串可以看作是数组 var index = h[2]; /* * 需要特别注意的是，字符串是不可变的， * 如果对字符串的某个索引赋值， * 不会有任何错误，但是，也没有任何效果： **/ h[1] = 'k'; /* indexOf()会搜索指定字符串出现的位置, 没有找到指定的子串，返回-1 */ var k = h.indexOf(\"world\"); /* substring()返回指定索引区间的子串： 跟java语法差不多 */ var sub = h.substring(0,2); length => 11 index => \"e\" h[1] => \"e\" k => 6 sub => \"he\" "},"基础/数组.html":{"url":"基础/数组.html","title":"数组","keywords":"","body":"数组 JavaScript的Array可以包含任意数据类型，并通过索引来访问每个元素。 var array = [0.1,'a',false,null]; // 通过length获取数组的长度 var length = array.length; /* 之前在字符串那里提过，索引字符串的某个字符, 不同的是，它对索引赋值,array的值会发生变化 */ array[1] = \"b\"; /* 对数组的长度直接赋值,数组的长度也会相应变化 如下面的,array的长度已变为 6, 后面的以 undefined 填充, 如果修改的length 比原来的更短, 则把多余的元素去掉 */ array.length = 6; // 如果通过索引赋值时，索引超过了范围，同样会引起Array大小的变化： array[7] = 7; array => [0.1,'b',false,null] 赋值后 大多数其他编程语言不允许直接改变数组的大小，越界访问索引会报错。然而，JavaScript的Array却不会有任何错误。在编写代码时，不建议直接修改Array的大小，访问索引时要确保索引不会越界。 Array 的常用方法 indexOf 与String类似，Array也可以通过indexOf()来搜索一个指定的元素的位置 slice slice()就是对应String的substring()版本，它截取Array的部分元素，然后返回一个新的Array, 如果不给slice()传递任何参数，它就会从头到尾截取所有元素。利用这一点，我们可以很容易地复制一个Array var arr = ['A', 'B', 'C', 'D', 'E', 'F', 'G']; arr.slice(0, 3); // 从索引0开始，到索引3结束，但不包括索引3: ['A', 'B', 'C'] arr.slice(3); // 从索引3开始到结束: ['D', 'E', 'F', 'G'] var arr = ['A', 'B', 'C', 'D', 'E', 'F', 'G']; var aCopy = arr.slice(); aCopy === arr; // false push 和pop push()向Array的末尾添加若干元素，pop()则把Array的最后一个元素删除掉： var arr = [1, 2]; arr.push('A', 'B'); // 返回Array新的长度: 4 arr; // [1, 2, 'A', 'B'] arr.pop(); // pop()返回'B' arr; // [1, 2, 'A'] arr.pop(); arr.pop(); arr.pop(); // 连续pop 3次 arr; // [] arr.pop(); // 空数组继续pop不会报错，而是返回undefined arr; // [] unshift 和 shift 如果要往Array的头部添加若干元素，使用unshift()方法，shift()方法则把Array的第一个元素删掉： var arr = [1, 2]; arr.unshift('A', 'B'); // 返回Array新的长度: 4 arr; // ['A', 'B', 1, 2] arr.shift(); // 'A' arr; // ['B', 1, 2] arr.shift(); arr.shift(); arr.shift(); // 连续shift 3次 arr; // [] arr.shift(); // 空数组继续shift不会报错，而是返回undefined arr; // [] sort sort()可以对当前Array进行排序，它会直接修改当前Array的元素位置，直接调用时，按照默认顺序排序: var arr = ['B', 'C', 'A']; arr.sort(); arr; // ['A', 'B', 'C'] reverse reverse()把整个Array的元素给掉个个，也就是反转： var arr = ['one', 'two', 'three']; arr.reverse(); arr; // ['three', 'two', 'one'] splice splice()方法是修改Array的“万能方法”，它可以从指定的索引开始删除若干元素，然后再从该位置添加若干元素： var arr = ['Microsoft', 'Apple', 'Yahoo', 'AOL', 'Excite', 'Oracle']; // 从索引2开始删除3个元素,然后再添加两个元素: arr.splice(2, 3, 'Google', 'Facebook'); // 返回删除的元素 ['Yahoo', 'AOL', 'Excite'] arr; // ['Microsoft', 'Apple', 'Google', 'Facebook', 'Oracle'] // 只删除,不添加: arr.splice(2, 2); // ['Google', 'Facebook'] arr; // ['Microsoft', 'Apple', 'Oracle'] // 只添加,不删除: arr.splice(2, 0, 'Google', 'Facebook'); // 返回[],因为没有删除任何元素 arr; // ['Microsoft', 'Apple', 'Google', 'Facebook', 'Oracle'] join join()方法是一个非常实用的方法，它把当前Array的每个元素都用指定的字符串连接起来，然后返回连接后的字符串： var arr = ['A', 'B', 'C', 1, 2, 3]; arr.join('-'); // 'A-B-C-1-2-3' 如果Array的元素不是字符串，将自动转换为字符串后再连接。 "},"基础/函数.html":{"url":"基础/函数.html","title":"函数","keywords":"","body":"函数 "},"基础/函数1.html":{"url":"基础/函数1.html","title":"函数定义调用","keywords":"","body":"函数 定义函数 在JavaScript中，定义函数的方式如下： function abs(x) { if (x >= 0) { return x; } else { return -x; } } 请注意，函数体内部的语句在执行时，一旦执行到return时，函数就执行完毕，并将结果返回。因此，函数内部通过条件判断和循环可以实现非常复杂的逻辑。 如果没有return语句，函数执行完毕后也会返回结果，只是结果为undefined。 由于JavaScript的函数也是一个对象，上述定义的abs()函数实际上是一个函数对象，而函数名abs可以视为指向该函数的变量。 因此，第二种定义函数的方式如下： var abs = function (x) { if (x >= 0) { return x; } else { return -x; } }; 在这种方式下，function (x) { ... }是一个匿名函数，它没有函数名。但是，这个匿名函数赋值给了变量abs，所以，通过变量abs就可以调用该函数。 上述两种定义完全等价，注意第二种方式按照完整语法需要在函数体末尾加一个;，表示赋值语句结束。 调用函数 由于JavaScript允许传入任意个参数而不影响调用，因此传入的参数比定义的参数多也没有问题，虽然函数内部并不需要这些参数： abs(10, 'blablabla'); // 返回10 abs(-9, 'haha', 'hehe', null); // 返回9 传入的参数比定义的少也没有问题： abs(); // 返回NaN 此时abs(x)函数的参数x将收到undefined，计算结果为NaN。 要避免收到undefined，可以对参数进行检查： function abs(x) { if (typeof x !== 'number') { throw 'Not a number'; } if (x >= 0) { return x; } else { return -x; } } arguments JavaScript还有一个免费赠送的关键字arguments，它只在函数内部起作用，并且永远指向当前函数的调用者传入的所有参数。arguments类似Array但它不是一个Array： function foo(x) { console.log('x = ' + x); // 10 for (var i=0; i x = 10 arg 0 = 10 arg 1 = 20 arg 2 = 30 实际上arguments最常用于判断传入参数的个数。你可能会看到这样的写法： // foo(a[, b], c) // 接收2~3个参数，b是可选参数，如果只传2个参数，b默认为null： function foo(a, b, c) { if (arguments.length === 2) { // 实际拿到的参数是a和b，c为undefined c = b; // 把b赋给c b = null; // b变为默认值 } // ... } rest参数 由于JavaScript函数允许接收任意个参数，于是我们就不得不用arguments来获取所有参数： function foo(a, b) { var i, rest = []; if (arguments.length > 2) { for (i = 2; i 为了获取除了已定义参数a、b之外的参数，我们不得不用arguments，并且循环要从索引2开始以便排除前两个参数，这种写法很别扭，只是为了获得额外的rest参数，有没有更好的方法？ ES6标准引入了rest参数，上面的函数可以改写为： function foo(a, b, ...rest) { console.log('a = ' + a); console.log('b = ' + b); console.log(rest); } foo(1, 2, 3, 4, 5); // 结果: // a = 1 // b = 2 // Array [ 3, 4, 5 ] foo(1); // 结果: // a = 1 // b = undefined // Array [] rest参数只能写在最后，前面用...标识，从运行结果可知，传入的参数先绑定a、b，多余的参数以数组形式交给变量rest，所以，不再需要arguments我们就获取了全部参数。 如果传入的参数连正常定义的参数都没填满，也不要紧，rest参数会接收一个空数组（注意不是undefined）。 "},"基础/函数2.html":{"url":"基础/函数2.html","title":"变量作用域与解构赋值","keywords":"","body":"变量作用域与解构赋值 局部作用域 由于JavaScript的变量作用域实际上是函数内部，我们在for循环等语句块中是无法定义具有局部作用域的变量的： 'use strict'; function foo() { for (var i=0; i 为了解决块级作用域，ES6引入了新的关键字let，用let替代var可以申明一个块级作用域的变量： 'use strict'; function foo() { var sum = 0; for (let i=0; i 常量 由于var和let申明的是变量，如果要申明一个常量，在ES6之前是不行的，我们通常用全部大写的变量来表示“这是一个常量，不要修改它的值”： var PI = 3.14; ES6标准引入了新的关键字const来定义常量，const与let都具有块级作用域： 'use strict'; const PI = 3.14; PI = 3; // 某些浏览器不报错，但是无效果！ PI; // 3.14 解构赋值 从ES6开始，JavaScript引入了解构赋值，可以同时对一组变量进行赋值。 什么是解构赋值？我们先看看传统的做法，如何把一个数组的元素分别赋值给几个变量： var array = ['hello', 'JavaScript', 'ES6']; var x = array[0]; var y = array[1]; var z = array[2]; 现在，在ES6中，可以使用解构赋值，直接对多个变量同时赋值： // 如果浏览器支持解构赋值就不会报错: var [x, y, z] = ['hello', 'JavaScript', 'ES6']; 注意，对数组元素进行解构赋值时，多个变量要用[...]括起来。 如果数组本身还有嵌套，也可以通过下面的形式进行解构赋值，注意嵌套层次和位置要保持一致： let [x, [y, z]] = ['hello', ['JavaScript', 'ES6']]; x; // 'hello' y; // 'JavaScript' z; // 'ES6' 解构赋值还可以忽略某些元素： let [, , z] = ['hello', 'JavaScript', 'ES6']; // 忽略前两个元素，只对z赋值第三个元素 z; // 'ES6' 对一个对象进行解构赋值时，同样可以直接对嵌套的对象属性进行赋值，只要保证对应的层次是一致的： var person = { name: '小明', age: 20, gender: 'male', passport: 'G-12345678', school: 'No.4 middle school', address: { city: 'Beijing', street: 'No.1 Road', zipcode: '100001' } }; var {name, address: {city, zip}} = person; name; // '小明' city; // 'Beijing' zip; // undefined, 因为属性名是zipcode而不是zip // 注意: address不是变量，而是为了让city和zip获得嵌套的address对象的属性: address; // Uncaught ReferenceError: address is not defined 使用解构赋值对对象属性进行赋值时，如果对应的属性不存在，变量将被赋值为undefined，这和引用一个不存在的属性获得undefined是一致的。如果要使用的变量名和属性名不一致，可以用下面的语法获取： var person = { name: '小明', age: 20, gender: 'male', passport: 'G-12345678', school: 'No.4 middle school' }; // 把passport属性赋值给变量id: let {name, passport:id} = person; name; // '小明' id; // 'G-12345678' // 注意: passport不是变量，而是为了让变量id获得passport属性: passport; // Uncaught ReferenceError: passport is not defined 解构赋值还可以使用默认值，这样就避免了不存在的属性返回undefined的问题： var person = { name: '小明', age: 20, gender: 'male', passport: 'G-12345678' }; // 如果person对象没有single属性，默认赋值为true: var {name, single=true} = person; name; // '小明' single; // true 有些时候，如果变量已经被声明了，再次赋值的时候，正确的写法也会报语法错误： // 声明变量: var x, y; // 解构赋值: {x, y} = { name: '小明', x: 100, y: 200}; // 语法错误: Uncaught SyntaxError: Unexpected token = 这是因为JavaScript引擎把{开头的语句当作了块处理，于是=不再合法。解决方法是用小括号括起来： ({x, y} = { name: '小明', x: 100, y: 200}); 使用场景 解构赋值在很多时候可以大大简化代码。例如，交换两个变量x和y的值，可以这么写，不再需要临时变量： var x=1, y=2; [x, y] = [y, x] 快速获取当前页面的域名和路径： var {hostname:domain, pathname:path} = location; 如果一个函数接收一个对象作为参数，那么，可以使用解构直接把对象的属性绑定到变量中。例如，下面的函数可以快速创建一个Date对象： function buildDate({year, month, day, hour=0, minute=0, second=0}) { return new Date(year + '-' + month + '-' + day + ' ' + hour + ':' + minute + ':' + second); } 它的方便之处在于传入的对象只需要year、month和day这三个属性： buildDate({ year: 2017, month: 1, day: 1 }); // Sun Jan 01 2017 00:00:00 GMT+0800 (CST) 也可以传入hour、minute和second属性： buildDate({ year: 2017, month: 1, day: 1, hour: 20, minute: 15 }); // Sun Jan 01 2017 20:15:00 GMT+0800 (CST) 使用解构赋值可以减少代码量，但是，需要在支持ES6解构赋值特性的现代浏览器中才能正常运行。目前支持解构赋值的浏览器包括Chrome，Firefox，Edge等。 "},"基础/函数3.html":{"url":"基础/函数3.html","title":"方法函数","keywords":"","body":"方法 在一个对象中绑定函数，称为这个对象的方法。 在JavaScript中，对象的定义是这样的： var xiaoming = { name: '小明', birth: 1990 }; 但是，如果我们给xiaoming绑定一个函数，就可以做更多的事情。比如，写个age()方法，返回xiaoming的年龄： var xiaoming = { name: '小明', birth: 1990, age: function () { var y = new Date().getFullYear(); return y - this.birth; } }; xiaoming.age; // function xiaoming.age() xiaoming.age(); // 今年调用是25,明年调用就变成26了 绑定到对象上的函数称为方法，和普通函数也没啥区别，但是它在内部使用了一个this关键字，这个东东是什么？ 在一个方法内部，this是一个特殊变量，它始终指向当前对象，也就是xiaoming这个变量。所以，this.birth可以拿到xiaoming的birth属性。 让我们拆开写： function getAge() { var y = new Date().getFullYear(); return y - this.birth; } var xiaoming = { name: '小明', birth: 1990, age: getAge }; xiaoming.age(); // 25, 正常结果 getAge(); // NaN 单独调用函数getAge()怎么返回了NaN？请注意，我们已经进入到了JavaScript的一个大坑里。 JavaScript的函数内部如果调用了this，那么这个this到底指向谁？ 答案是，视情况而定！ 如果以对象的方法形式调用，比如xiaoming.age()，该函数的this指向被调用的对象，也就是xiaoming，这是符合我们预期的。 如果单独调用函数，比如getAge()，此时，该函数的this指向全局对象，也就是window。 坑爹啊！ 更坑爹的是，如果这么写： var fn = xiaoming.age; // 先拿到xiaoming的age函数 fn(); // NaN 也是不行的！要保证this指向正确，必须用obj.xxx()的形式调用！ 由于这是一个巨大的设计错误，要想纠正可没那么简单。ECMA决定，在strict模式下让函数的this指向undefined，因此，在strict模式下，你会得到一个错误: var xiaoming = { name: '小明', birth: 1990, age: function () { var y = new Date().getFullYear(); return y - this.birth; } }; var fn = xiaoming.age; fn(); // Uncaught TypeError: Cannot read property 'birth' of undefined apply 虽然在一个独立的函数调用中，根据是否是strict模式，this指向undefined或window，不过，我们还是可以控制this的指向的！ 要指定函数的this指向哪个对象，可以用函数本身的apply方法，它接收两个参数，第一个参数就是需要绑定的this变量，第二个参数是Array，表示函数本身的参数。 用apply修复getAge()调用： function getAge() { var y = new Date().getFullYear(); return y - this.birth; } var xiaoming = { name: '小明', birth: 1990, age: getAge }; xiaoming.age(); // 25 getAge.apply(xiaoming, []); // 25, this指向xiaoming, 参数为空 另一个与apply()类似的方法是call()，唯一区别是： apply()把参数打包成Array再传入； call()把参数按顺序传入。 比如调用Math.max(3, 5, 4)，分别用apply()和call()实现如下： Math.max.apply(null, [3, 5, 4]); // 5 Math.max.call(null, 3, 5, 4); // 5 对普通函数调用，我们通常把this绑定为null。 "},"基础/高阶函数.html":{"url":"基础/高阶函数.html","title":"高阶函数","keywords":"","body":"高阶函数 JavaScript的函数其实都指向某个变量。既然变量可以指向函数，函数的参数能接收变量，那么一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数。 一个最简单的高阶函数： function add(x, y, f) { return f(x) + f(y); } "},"基础/map-reduce.html":{"url":"基础/map-reduce.html","title":"map/reduce","keywords":"","body":"map/reduce map 举例说明，比如我们有一个函数f(x)=x2，要把这个函数作用在一个数组[1, 2, 3, 4, 5, 6, 7, 8, 9]上，就可以用map实现如下： 由于map()方法定义在JavaScript的Array中，我们调用Array的map()方法，传入我们自己的函数，就得到了一个新的Array作为结果： function pow(x) { return x * x; } var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]; var results = arr.map(pow); // [1, 4, 9, 16, 25, 36, 49, 64, 81] reduce 再看reduce的用法。Array的reduce()把一个函数作用在这个Array的[x1, x2, x3...]上，这个函数必须接收两个参数，reduce()把结果继续和序列的下一个元素做累积计算，其效果就是： [x1, x2, x3, x4].reduce(f) = f(f(f(x1, x2), x3), x4) 比方说对一个Array求和，就可以用reduce实现： var arr = [1, 3, 5, 7, 9]; arr.reduce(function (x, y) { return x + y; }); // 25 "},"基础/filter.html":{"url":"基础/filter.html","title":"filter","keywords":"","body":"filter filter也是一个常用的操作，它用于把Array的某些元素过滤掉，然后返回剩下的元素。 和map()类似，Array的filter()也接收一个函数。和map()不同的是，filter()把传入的函数依次作用于每个元素，然后根据返回值是true还是false决定保留还是丢弃该元素。 例如： let arr = [1,2,4,5,6,9,10]; // 获取和 let sum = arr.reduce(function (x,y) { return x+y; }); // 获取长度 let length = arr.length; // 取得平均数 let average = sum / length; // 保留大于平均数的数 let r = arr.filter(function (x) { return x > average; });//[ 6, 9, 10 ] 把一个Array中的去空，可以这么写： const array = ['a','','b','','c',null]; const notEmptyArray = array.filter(function (x) { return x && x.trim(); }); // [ 'a', 'b', 'c' ] 利用filter，可以巧妙地去除Array的重复元素： const repeatArray = [1,2,11,2,3,4,1]; let notRepeatArray = repeatArray.filter(function (x, index, self) { return self.indexOf(x) === index; }); // [ 1, 2, 11, 3, 4 ] 筛选素数： const randomArray = []; for (let i = 1; i "},"基础/sort.html":{"url":"基础/sort.html","title":"sort","keywords":"","body":"sort JavaScript的Array的sort()方法就是用于排序的，但是排序结果可能让你大吃一惊： // 看上去正常的结果: ['Google', 'Apple', 'Microsoft'].sort(); // ['Apple', 'Google', 'Microsoft']; // apple排在了最后: ['Google', 'apple', 'Microsoft'].sort(); // ['Google', 'Microsoft\", 'apple'] // 无法理解的结果: [10, 20, 1, 2].sort(); // [1, 10, 2, 20] 第二个排序把apple排在了最后，是因为字符串根据ASCII码进行排序，而小写字母a的ASCII码在大写字母之后。 第三个排序结果是什么鬼？简单的数字排序都能错？ 这是因为Array的sort()方法默认把所有元素先转换为String再排序，结果'10'排在了'2'的前面，因为字符'1'比字符'2'的ASCII码小。 如果不知道sort()方法的默认排序规则，直接对数字排序，绝对栽进坑里！ 幸运的是，sort()方法也是一个高阶函数，它还可以接收一个比较函数来实现自定义的排序。 const numberArray = [10,20,1,2]; numberArray.sort(function (x, y) { return x-y; // 返回正数则调换位置 }); // [ 1, 2, 10, 20 ] 对字符串的排序: stringArray.sort(function (x, y) { const upperX = x.toLocaleUpperCase(); const upperY = y.toLocaleUpperCase(); if (upperX upperY){ return 1; }else{ return 0; } }); // [ 'apple', 'Google', 'Microsoft' ] 最后友情提示，sort()方法会直接对Array进行修改，它返回的结果仍是当前Array： var a1 = ['B', 'A', 'C']; var a2 = a1.sort(); a1; // ['A', 'B', 'C'] a2; // ['A', 'B', 'C'] a1 === a2; // true, a1和a2是同一对象 "},"基础/array其他方法.html":{"url":"基础/array其他方法.html","title":"array其他方法","keywords":"","body":"array其他方法 every every()方法可以判断数组的所有元素是否满足测试条件。 例如，给定一个包含若干字符串的数组，判断所有字符串是否满足指定的测试条件： const fruit = ['Apple','pear','orange']; const isMoreThan = fruit.every(function (value) { return value.length > 3; }); // true const isLower = fruit.every(function (value) { return value.toLowerCase() === value; }); // false find find()方法用于查找符合条件的第一个元素，如果找到了，返回这个元素，否则，返回undefined： const fruit = ['Apple','pear','orange']; const findLower = fruit.find(function (value) { return value.toLowerCase() === value; }); // pear const findUpper = fruit.find(function (value) { return value.toUpperCase() === value; }); // undefined findIndex findIndex()和find()类似，也是查找符合条件的第一个元素，不同之处在于findIndex()会返回这个元素的索引，如果没有找到，返回-1. forEach forEach()和map()类似，它也把每个元素依次作用于传入的函数，但不会返回新的数组。forEach()常用于遍历数组，因此，传入的函数不需要返回值： const fruit = ['Apple','pear','orange']; fruit.forEach(function (value) { console.log(value); }); "},"基础/闭包.html":{"url":"基础/闭包.html","title":"闭包","keywords":"","body":"闭包 函数作为返回值 高阶函数除了可以接受函数作为参数外，还可以把函数作为结果值返回。 我们来实现一个对Array的求和。但是，如果不需要立刻求和，而是在后面的代码中，根据需要再计算怎么办？可以不返回求和的结果，而是返回求和的函数！ function lazySum(arr) { return function () { return arr.reduce(function (x, y) { return x+y; }) } } 调用函数f时，才真正计算求和的结果： let f = lazySum([1, 2, 3, 4, 5]); // function sum() 请再注意一点，当我们调用lazySum()时，每次调用都会返回一个新的函数，即使传入相同的参数： let f1= lazySum([1,2,3,4,5]); let f2 = lazySum([1,2,3,4,5]); console.log(f1 === f2); //false 说了这么多，难道闭包就是为了返回一个函数然后延迟执行吗？ 当然不是！闭包有非常强大的功能。举个栗子： 在面向对象的程序设计语言里，比如Java和C++，要在对象内部封装一个私有变量，可以用private修饰一个成员变量。 在没有class机制，只有函数的语言里，借助闭包，同样可以封装一个私有变量。我们用JavaScript创建一个计数器： function create_counter(initial) { let x = initial||0; return { increase(){ x += 1; return x; } } } 它用起来像这样： var c1 = create_counter(); c1.inc(); // 1 c1.inc(); // 2 c1.inc(); // 3 var c2 = create_counter(10); c2.inc(); // 11 c2.inc(); // 12 c2.inc(); // 13 "},"基础/箭头函数.html":{"url":"基础/箭头函数.html","title":"箭头函数","keywords":"","body":"箭头函数 ES6标准新增了一种新的函数：Arrow Function（箭头函数）。 x => x*x; 上面的箭头函数相当于（匿名函数）： function (x) { return x * x; } 那怎么调用，就是将其赋值给变量,如： const pow = x => x * x; console.log(pow(2)); // 4 箭头函数相当于匿名函数，并且简化了函数定义。箭头函数有两种格式，一种像上面的，只包含一个表达式，连{ ... }和return都省略掉了。还有一种可以包含多条语句，这时候就不能省略{ ... }和return 如果参数不是一个，就需要用括号()括起来： // 两个参数: (x, y) => x * x + y * y // 无参数: () => 3.14 // 可变参数: (x, y, ...rest) => { var i, sum = x + y; for (i=0; i 如果要返回一个对象，就要注意，如果是单表达式，这么写的话会报错： // SyntaxError: x => { foo: x } 因为和函数体的{ ... }有语法冲突，所以要改为： // ok: x => ({ foo: x }) this 箭头函数看上去是匿名函数的一种简写，但实际上，箭头函数和匿名函数有个明显的区别：箭头函数内部的this是词法作用域，由上下文确定。 var obj = { birth: 1990, getAge: function (year) { var b = this.birth; // 1990 var fn = (y) => y - this.birth; // this.birth仍是1990 return fn.call({birth:2000}, year); } }; obj.getAge(2015); // 25 便利 如，之前的排序可以： let arr = [10,20,1,2]; arr.sort((x,y)=>x-y); "},"基础/generator.html":{"url":"基础/generator.html","title":"generator","keywords":"","body":"generator generator（生成器）是ES6标准引入的新的数据类型。一个generator看上去像一个函数，但可以返回多次。 函数在执行过程中，如果没有遇到return语句（函数末尾如果没有return，就是隐含的return undefined;），控制权无法交回被调用的代码。 generator和函数不同的是，generator由function*定义（注意多出的*号），并且，除了return语句，还可以用yield返回多次。 我们以一个著名的斐波那契数列为例，它由0，1开头： function* fib(max) { var t, a = 0, b = 1, n = 0; while (n 直接调用一个generator和调用函数不一样，fib(5)仅仅是创建了一个generator对象，还没有去执行它。 调用generator对象有两个方法，一是不断地调用generator对象的next()方法： var f = fib(5); f.next(); // {value: 0, done: false} f.next(); // {value: 1, done: false} f.next(); // {value: 1, done: false} f.next(); // {value: 2, done: false} f.next(); // {value: 3, done: false} f.next(); // {value: undefined, done: true} 要生成一个自增的ID，可以编写一个next_id()函数： function* nextId() { let currentId = 0; while (true){ yield currentId+=1; } } const f = nextId(); console.log(f.next()); console.log(f.next()); "},"基础/标准对象.html":{"url":"基础/标准对象.html","title":"标准对象","keywords":"","body":"标准对象 在JavaScript的世界里，一切都是对象。 但是某些对象还是和其他对象不太一样。为了区分对象的类型，我们用typeof操作符获取对象的类型，它总是返回一个字符串： typeof 123; // 'number' typeof NaN; // 'number' typeof 'str'; // 'string' typeof true; // 'boolean' typeof undefined; // 'undefined' typeof Math.abs; // 'function' typeof null; // 'object' typeof []; // 'object' typeof {}; // 'object' 可见，number、string、boolean、function和undefined有别于其他类型。特别注意null的类型是object，Array的类型也是object，如果我们用typeof将无法区分出null、Array和通常意义上的object——{}。 包装对象 除了这些类型外，JavaScript还提供了包装对象，熟悉Java的小伙伴肯定很清楚int和Integer这种暧昧关系。 number、boolean和string都有包装对象。没错，在JavaScript中，字符串也区分string类型和它的包装类型。包装对象用new创建： var n = new Number(123); // 123,生成了新的包装类型 var b = new Boolean(true); // true,生成了新的包装类型 var s = new String('str'); // 'str',生成了新的包装类型 虽然包装对象看上去和原来的值一模一样，显示出来也是一模一样，但他们的类型已经变为object了！所以，包装对象和原始值用===比较会返回false： typeof new Number(123); // 'object' new Number(123) === 123; // false typeof new Boolean(true); // 'object' new Boolean(true) === true; // false typeof new String('str'); // 'object' new String('str') === 'str'; // false 所以闲的蛋疼也不要使用包装对象！尤其是针对string类型！！！ 如果我们在使用Number、Boolean和String时，没有写new会发生什么情况？ 此时，Number()、Boolean和String()被当做普通函数，把任何类型的数据转换为number、boolean和string类型（注意不是其包装类型）： var n = Number('123'); // 123，相当于parseInt()或parseFloat() typeof n; // 'number' var b = Boolean('true'); // true typeof b; // 'boolean' var b2 = Boolean('false'); // true! 'false'字符串转换结果为true！因为它是非空字符串！ var b3 = Boolean(''); // false var s = String(123.45); // '123.45' typeof s; // 'string' 总结一下，有这么几条规则需要遵守： 不要使用new Number()、new Boolean()、new String()创建包装对象； 用parseInt()或parseFloat()来转换任意类型到number； 用String()来转换任意类型到string，或者直接调用某个对象的toString()方法； 通常不必把任意类型转换为boolean再判断，因为可以直接写if (myVar) {...}； typeof操作符可以判断出number、boolean、string、function和undefined； 判断Array要使用Array.isArray(arr)； 判断null请使用myVar === null； 判断某个全局变量是否存在用typeof window.myVar === 'undefined'； 函数内部判断某个变量是否存在用typeof myVar === 'undefined'。 任何对象都有toString()方法吗？null和undefined就没有！确实如此，这两个特殊值要除外，虽然null还伪装成了object类型。number对象调用toString()报SyntaxError： const number = 123; console.log(number.toString()); // 123 console.log(123.toString()); // error console.log(123..toString()); // 123 综上，个人认为是，它将 123. 看成是一个小数，然后你直接跟toString()，它不会认为 . 是调用方法，而是看成是数字的一部分。 "},"基础/Date.html":{"url":"基础/Date.html","title":"Date","keywords":"","body":"Date 在JavaScript中，Date对象用来表示日期和时间。 要获取系统当前时间，用： const date = new Date();// 注意要new 否则调用不了方法 console.log(date.toString()); // Sat Aug 31 2019 19:09:13 GMT+0800 (GMT+08:00) console.log(date.getFullYear()); // 2019, 年份 console.log(date.getMonth()); // 7,月份，注意月份范围是0~11，7表示八月 console.log(date.getDate()); // 31号 console.log(date.getDay()); // 6,星期六 console.log(date.getHours()); // 18,时 console.log(date.getMinutes()); // 52,分 console.log(date.getSeconds()); // 24,秒 console.log(date.getMilliseconds()); // 202,毫秒 console.log(date.getTime()); //1567248744202 时间戳 如果要创建一个指定日期和时间的Date对象，可以用： // 获取指定时间 const next = new Date(2020,1,1,1,1,1); console.log(next.toString()); // Sat Feb 01 2020 01:01:01 GMT+0800 (GMT+08:00) 更有意思的是，还能够用来自动更正时间： // 传入一个错误的时间 会自动校正 const errorDate = new Date(2020,1,55,1,1,1); console.log(errorDate.toString()); // Thu Mar 26 2020 01:01:01 GMT+0800 (GMT+08:00) 一定要注意月份的问题，0-11。 第二种创建一个指定日期和时间的方法是解析一个符合ISO 8601格式的字符串： const isoDate = Date.parse('2020-09-23T22:49:22.875+08:00'); console.log(isoDate.toString()); // 1600872562875 但它返回的不是Date对象，而是一个时间戳。不过有时间戳就可以很容易地把它转换为一个Date： const timeStampDate = new Date(1600872562875); console.log(timeStampDate.toString()); // Wed Sep 23 2020 22:49:22 GMT+0800 (GMT+08:00) 时区 Date对象表示的时间总是按浏览器所在时区显示的，不过我们既可以显示本地时间，也可以显示调整后的UTC时间： const localDate = new Date(); // 获取本地时间 console.log(localDate.toLocaleString()); // 2019-8-31 19:21:54 // 获取 UTC 时间 相差8小时 console.log(localDate.toUTCString()); // Sat, 31 Aug 2019 11:21:54 GMT console.log(localDate.toLocaleDateString()); // 2019-8-31 console.log(localDate.toLocaleTimeString()); // 19:21:54 "},"基础/RepExp.html":{"url":"基础/RepExp.html","title":"正则表达式","keywords":"","body":"正则表达式 JS 的正则表达式跟 Java 的正则表达式类似。 用\\d可以匹配一个数字，\\w可以匹配一个字母或数字, .可以匹配任意一个字符。 要匹配变长的字符，在正则表达式中，用*表示任意个字符（包括0个），用+表示至少一个字符，用?表示0个或1个字符，用{n}表示n个字符，用{n,m}表示n-m个字符。 \\s 可以匹配一个空格（包括Tab等空白符）。 要做更精确地匹配，可以用[]表示范围，比如： [0-9a-zA-Z\\_]可以匹配一个数字、字母或者下划线； [0-9a-zA-Z\\_]+可以匹配至少由一个数字、字母或者下划线组成的字符串，比如'a100'，'0_Z'，'js2015'等等； [a-zA-Z\\_\\$][0-9a-zA-Z\\_\\$]*可以匹配由字母或下划线、$开头，后接任意个由一个数字、字母或者下划线、$组成的字符串，也就是JavaScript允许的变量名； [a-zA-Z\\_\\$][0-9a-zA-Z\\_\\$]{0, 19}更精确地限制了变量的长度是1-20个字符（前面1个字符+后面最多19个字符）。 A|B可以匹配A或B，所以(J|j)ava(S|s)cript可以匹配'JavaScript'、'Javascript'、'javaScript'或者'javascript'。 ^表示行的开头，^\\d表示必须以数字开头。 $表示行的结束，\\d$表示必须以数字结束。 你可能注意到了，js也可以匹配'jsp'，但是加上^js$就变成了整行匹配，就只能匹配'js'了。整行匹配就是要全部匹配，不能多也不能少。 const js = /^js$/; console.log(js.test(\"jss\")); // false 切分字符串 用正则表达式切分字符串比用固定的字符更灵活，请看正常的切分代码： 'a b c'.split(' '); // ['a', 'b', '', '', 'c'] 嗯，无法识别连续的空格，用正则表达式试试： 'a b c'.split(/\\s+/); // ['a', 'b', 'c'] 无论多少个空格都可以正常分割。加入,试试： 'a,b, c d'.split(/[\\s\\,]+/); // ['a', 'b', 'c', 'd'] 再加入;试试： 'a,b;; c d'.split(/[\\s\\,\\;]+/); // ['a', 'b', 'c', 'd'] 如果用户输入了一组标签，下次记得用正则表达式来把不规范的输入转化成正确的数组。 分组 除了简单地判断是否匹配之外，正则表达式还有提取子串的强大功能。用()表示的就是要提取的分组（Group）。比如： ^(\\d{3})-(\\d{3,8})$分别定义了两个组，可以直接从匹配的字符串中提取出区号和本地号码： var re = /^(\\d{3})-(\\d{3,8})$/; re.exec('010-12345'); // ['010-12345', '010', '12345'] re.exec('010 12345'); // null 如果正则表达式中定义了组，就可以在RegExp对象上用exec()方法提取出子串来。 exec()方法在匹配成功后，会返回一个Array，第一个元素是正则表达式匹配到的整个字符串，后面的字符串表示匹配成功的子串。 exec()方法在匹配失败时返回null。 贪婪匹配 需要特别指出的是，正则匹配默认是贪婪匹配，也就是匹配尽可能多的字符。举例如下，匹配出数字后面的0： var re = /^(\\d+)(0*)$/; re.exec('102300'); // ['102300', '102300', ''] 由于\\d+采用贪婪匹配，直接把后面的0全部匹配了，结果0*只能匹配空字符串了。 必须让\\d+采用非贪婪匹配（也就是尽可能少匹配），才能把后面的0匹配出来，加个?就可以让\\d+采用非贪婪匹配： var re = /^(\\d+?)(0*)$/; re.exec('102300'); // ['102300', '1023', '00'] 全局搜索 JavaScript的正则表达式还有几个特殊的标志，最常用的是g，表示全局匹配： var r1 = /test/g; // 等价于: var r2 = new RegExp('test', 'g'); 全局匹配可以多次执行exec()方法来搜索一个匹配的字符串。当我们指定g标志后，每次运行exec()，正则表达式本身会更新lastIndex属性，表示上次匹配到的最后索引： var s = 'JavaScript, VBScript, JScript and ECMAScript'; var re=/[a-zA-Z]+Script/g; // 使用全局匹配: re.exec(s); // ['JavaScript'] re.lastIndex; // 10 re.exec(s); // ['VBScript'] re.lastIndex; // 20 re.exec(s); // ['JScript'] re.lastIndex; // 29 re.exec(s); // ['ECMAScript'] re.lastIndex; // 44 re.exec(s); // null，直到结束仍没有匹配到 全局匹配类似搜索，因此不能使用/^...$/，那样只会最多匹配一次。 正则表达式还可以指定i标志，表示忽略大小写，m标志，表示执行多行匹配。 "},"基础/正则表达式.html":{"url":"基础/正则表达式.html","title":"正则表达式别篇","keywords":"","body":"正则表达式 语法 /正则表达式主体/修饰符(可选) 正则表达式主体即正则表达式。 修饰符的话，则有三种，如下： 修饰符 描述 i 执行对大小写不敏感的匹配。 g 执行全局匹配（查找所有匹配而非在找到第一个匹配后停止）。 m 执行多行匹配。 对于字符串而言，正则表达式通常有两个方法：search() 和 replace(),显然前者是检索后者是替换。 现在我们来尝试一下： var str = \"Hello World\"; // i 搜索不区分大小写 返回第一次出现的位置 // 例如：下面检索 第一次出现world的地方 var i = str.search(/WORLD/i); // g 是区分大小写的,并且是全局搜索 var g = str.search(/L/g); // 对于 m 测试发现,用处真的不是很大,g 就可以了 var str2 = \"1\\n 2\\n 3\\n\"; var g2 = str2.search(/2/g); var m2 = str2.search(/2/m); // 替换字符串 var str3 = \"AABB\"; // 仅将第一次出现的 A的替换成 1 var i3 = str3.replace(/a/i,\"1\"); // 既全局匹配又忽略大小写,将所有的A均替换为1,修饰符可以直接拼接,是&的关系 var gi3 = str3.replace(/a/gi,\"1\"); i => 6 g => -1 上面没有大写的L 所以返回 -1 g2 => 3 m2 => 3 str3 => AABB 替换后，原来的字符串是不变的，返回的string才变了 i3 => 1ABB gi3 => 11BB 以上是字符串的方法。 对于正则表达式，JavaScript 里有一个预定义了属性和方法的正则表达式对象 RegExp 。 该对象有两个方法：test() 和 exec(). 现在尝试一下： var rep = /a/i; // 另种写法,new 一个RegExp 对象,也可以省略,用上面的写法也行 // var rep = new RegExp(/a/i); // 该方法会返回一个boolean 类型,如果有符合正则表达式返回true,反之返回false var test = rep.test(\"abcd\"); // 该方法会返回一个数组 var exec = rep.exec(\"abcd\"); test => true exec => [ 'a', index: 0, input: 'abcd' ] "},"基础/json.html":{"url":"基础/json.html","title":"JSON","keywords":"","body":"JSON JSON是JavaScript Object Notation的缩写，它是一种数据交换格式。 在JSON出现之前，大家一直用XML来传递数据。因为XML是一种纯文本格式，所以它适合在网络上交换数据。XML本身不算复杂，但是，加上DTD、XSD、XPath、XSLT等一大堆复杂的规范以后，任何正常的软件开发人员碰到XML都会感觉头大了，最后大家发现，即使你努力钻研几个月，也未必搞得清楚XML的规范。 终于，在2002年的一天，道格拉斯·克罗克福特（Douglas Crockford）同学为了拯救深陷水深火热同时又被某几个巨型软件企业长期愚弄的软件工程师，发明了JSON这种超轻量级的数据交换格式。 道格拉斯同学长期担任雅虎的高级架构师，自然钟情于JavaScript。他设计的JSON实际上是JavaScript的一个子集。在JSON中，一共就这么几种数据类型： number：和JavaScript的number完全一致； boolean：就是JavaScript的true或false； string：就是JavaScript的string； null：就是JavaScript的null； array：就是JavaScript的Array表示方式——[]； object：就是JavaScript的{ ... }表示方式。 以及上面的任意组合。 并且，JSON还定死了字符集必须是UTF-8，表示多语言就没有问题了。为了统一解析，JSON的字符串规定必须用双引号\"\"，Object的键也必须用双引号\"\"。 由于JSON非常简单，很快就风靡Web世界，并且成为ECMA标准。几乎所有编程语言都有解析JSON的库，而在JavaScript中，我们可以直接使用JSON，因为JavaScript内置了JSON的解析。 把任何JavaScript对象变成JSON，就是把这个对象序列化成一个JSON格式的字符串，这样才能够通过网络传递给其他计算机。 如果我们收到一个JSON格式的字符串，只需要把它反序列化成一个JavaScript对象，就可以在JavaScript中直接使用这个对象了。 序列化 const person = { name:\"Tom\", age:\"22\", phone:12345678910 }; const personString = JSON.stringify(person); // {\"name\":\"Tom\",\"age\":\"22\",\"phone\":12345678910} 要输出得好看一些，可以加上参数，按缩进输出： JSON.stringify(person,null,\" \"); { \"name\": \"Tom\", \"age\": \"22\", \"phone\": 12345678910 } 第二个参数用于控制如何筛选对象的键值，如果我们只想输出指定的属性，可以传入Array： JSON.stringify(person,[\"name\",\"age\"],\" \"); "},"基础/面向对象编程.html":{"url":"基础/面向对象编程.html","title":"面向对象编程","keywords":"","body":"面向对象编程 JavaScript的所有数据都可以看成对象，那是不是我们已经在使用面向对象编程了呢？ 当然不是。如果我们只使用Number、Array、string以及基本的{...}定义的对象，还无法发挥出面向对象编程的威力。 JavaScript不区分类和实例的概念，而是通过原型（prototype）来实现面向对象编程。 原型是指当我们想要创建xiaoming这个具体的学生时，我们并没有一个Student类型可用。那怎么办？恰好有这么一个现成的对象: const student = { name:\"Student\", height:1.2, run(){ console.log(this.name + \" is running...\"); } }; const xiaoming = { name: \"小明\" }; xiaoming.__proto__ = student; xiaoming.run(); // 小明 is running... 注意最后一行代码把xiaoming的原型指向了对象Student，看上去xiaoming仿佛是从Student继承下来的. 请注意，上述代码仅用于演示目的。在编写JavaScript代码时，不要直接用obj.__proto__去改变一个对象的原型，并且，低版本的IE也无法使用__proto__。Object.create()方法可以传入一个原型对象，并创建一个基于该原型的新对象，但是新对象什么属性都没有，因此，我们可以编写一个函数来创建xiaoming： // 原型对象: var Student = { name: 'Robot', height: 1.2, run: function () { console.log(this.name + ' is running...'); } }; function createStudent(name) { // 基于Student原型创建一个新对象: var s = Object.create(Student); // 初始化新对象: s.name = name; return s; } var xiaoming = createStudent('小明'); xiaoming.run(); // 小明 is running... xiaoming.__proto__ === Student; // true "},"基础/创建对象.html":{"url":"基础/创建对象.html","title":"创建对象","keywords":"","body":"创建对象 JavaScript对每个创建的对象都会设置一个原型，指向它的原型对象。 当我们用obj.xxx访问一个对象的属性时，JavaScript引擎先在当前对象上查找该属性，如果没有找到，就到其原型对象上找，如果还没有找到，就一直上溯到Object.prototype对象，最后，如果还没有找到，就只能返回undefined。 其原型链是： arr ----> Array.prototype ----> Object.prototype ----> null Array.prototype定义了indexOf()、shift()等方法，因此你可以在所有的Array对象上直接调用这些方法。 当我们创建一个函数时： function foo() { return 0; } 函数也是一个对象，它的原型链是： foo ----> Function.prototype ----> Object.prototype ----> null 由于Function.prototype定义了apply()等方法，因此，所有函数都可以调用apply()方法。 很容易想到，如果原型链很长，那么访问一个对象的属性就会因为花更多的时间查找而变得更慢，因此要注意不要把原型链搞得太长。 构造函数 除了直接用{ ... }创建一个对象外，JavaScript还可以用一种构造函数的方法来创建对象。它的用法是，先定义一个构造函数： function Student(name) { this.name = name; this.hello = function () { alert('Hello, ' + this.name + '!'); } } 你会问，咦，这不是一个普通函数吗？ 这确实是一个普通函数，但是在JavaScript中，可以用关键字new来调用这个函数，并返回一个对象： var xiaoming = new Student('小明'); xiaoming.name; // '小明' xiaoming.hello(); // Hello, 小明! 注意，如果不写new，这就是一个普通函数，它返回undefined。但是，如果写了new，它就变成了一个构造函数，它绑定的this指向新创建的对象，并默认返回this，也就是说，不需要在最后写return this;。 新创建的xiaoming的原型链是： xiaoming ----> Student.prototype ----> Object.prototype ----> null 也就是说，xiaoming的原型指向函数Student的原型。如果你又创建了xiaohong、xiaojun，那么这些对象的原型与xiaoming是一样的： xiaoming ↘ xiaohong -→ Student.prototype ----> Object.prototype ----> null xiaojun ↗ 用new Student()创建的对象还从原型上获得了一个constructor属性，它指向函数Student本身： xiaoming.constructor === Student.prototype.constructor; // true Student.prototype.constructor === Student; // true Object.getPrototypeOf(xiaoming) === Student.prototype; // true xiaoming instanceof Student; // true 看晕了吧？用一张图来表示这些乱七八糟的关系就是： 红色箭头是原型链。注意，Student.prototype指向的对象就是xiaoming、xiaohong的原型对象，这个原型对象自己还有个属性constructor，指向Student函数本身。 另外，函数Student恰好有个属性prototype指向xiaoming、xiaohong的原型对象，但是xiaoming、xiaohong这些对象可没有prototype这个属性，不过可以用__proto__这个非标准用法来查看。 现在我们就认为xiaoming、xiaohong这些对象“继承”自Student。 不过还有一个小问题，注意观察： xiaoming.name; // '小明' xiaohong.name; // '小红' xiaoming.hello; // function: Student.hello() xiaohong.hello; // function: Student.hello() xiaoming.hello === xiaohong.hello; // false xiaoming和xiaohong各自的name不同，这是对的，否则我们无法区分谁是谁了。 xiaoming和xiaohong各自的hello是一个函数，但它们是两个不同的函数，虽然函数名称和代码都是相同的！ 如果我们通过new Student()创建了很多对象，这些对象的hello函数实际上只需要共享同一个函数就可以了，这样可以节省很多内存。 要让创建的对象共享一个hello函数，根据对象的属性查找原则，我们只要把hello函数移动到xiaoming、xiaohong这些对象共同的原型上就可以了，也就是Student.prototype： 修改代码如下： function Student(name) { this.name = name; } Student.prototype.hello = function () { alert('Hello, ' + this.name + '!'); }; 用new创建基于原型的JavaScript的对象就是这么简单！ 我们还可以编写一个createStudent()函数，在内部封装所有的new操作。一个常用的编程模式像这样： function Student(props) { this.name = props.name || '匿名'; // 默认值为'匿名' this.grade = props.grade || 1; // 默认值为1 } Student.prototype.hello = function () { alert('Hello, ' + this.name + '!'); }; function createStudent(props) { return new Student(props || {}) } 这个createStudent()函数有几个巨大的优点：一是不需要new来调用，二是参数非常灵活，可以不传，也可以这么传： var xiaoming = createStudent({ name: '小明' }); xiaoming.grade; // 1 如果创建的对象有很多属性，我们只需要传递需要的某些属性，剩下的属性可以用默认值。由于参数是一个Object，我们无需记忆参数的顺序。如果恰好从JSON拿到了一个对象，就可以直接创建出xiaoming。 "},"基础/原型继承.html":{"url":"基础/原型继承.html","title":"原型继承","keywords":"","body":"原型继承 在传统的基于Class的语言如Java、C++中，继承的本质是扩展一个已有的Class，并生成新的Subclass。 由于这类语言严格区分类和实例，继承实际上是类型的扩展。但是，JavaScript由于采用原型继承，我们无法直接扩展一个Class，因为根本不存在Class这种类型。 但是办法还是有的。我们先回顾Student构造函数： function Student(props) { this.name = props.name || 'Unnamed'; } Student.prototype.hello = function () { alert('Hello, ' + this.name + '!'); } 以及Student的原型链： 现在，我们要基于Student扩展出PrimaryStudent，可以先定义出PrimaryStudent： function PrimaryStudent(props) { // 调用Student构造函数，绑定this变量: Student.call(this, props); this.grade = props.grade || 1; } 但是，调用了Student构造函数不等于继承了Student，PrimaryStudent创建的对象的原型是： new PrimaryStudent() ----> PrimaryStudent.prototype ----> Object.prototype ----> null 必须想办法把原型链修改为： new PrimaryStudent() ----> PrimaryStudent.prototype ----> Student.prototype ----> Object.prototype ----> null 我们必须借助一个中间对象来实现正确的原型链，这个中间对象的原型要指向Student.prototype。为了实现这一点，参考道爷（就是发明JSON的那个道格拉斯）的代码，中间对象可以用一个空函数F来实现： // PrimaryStudent构造函数: function PrimaryStudent(props) { Student.call(this, props); this.grade = props.grade || 1; } // 空函数F: function F() { } // 把F的原型指向Student.prototype: F.prototype = Student.prototype; // 把PrimaryStudent的原型指向一个新的F对象，F对象的原型正好指向Student.prototype: PrimaryStudent.prototype = new F(); // 把PrimaryStudent原型的构造函数修复为PrimaryStudent: PrimaryStudent.prototype.constructor = PrimaryStudent; // 继续在PrimaryStudent原型（就是new F()对象）上定义方法： PrimaryStudent.prototype.getGrade = function () { return this.grade; }; // 创建xiaoming: var xiaoming = new PrimaryStudent({ name: '小明', grade: 2 }); xiaoming.name; // '小明' xiaoming.grade; // 2 // 验证原型: xiaoming.__proto__ === PrimaryStudent.prototype; // true xiaoming.__proto__.__proto__ === Student.prototype; // true // 验证继承关系: xiaoming instanceof PrimaryStudent; // true xiaoming instanceof Student; // true 用一张图来表示新的原型链： 注意，函数F仅用于桥接，我们仅创建了一个new F()实例，而且，没有改变原有的Student定义的原型链。 "},"基础/class继承.html":{"url":"基础/class继承.html","title":"class继承","keywords":"","body":"class继承 JavaScript的对象模型是基于原型实现的，特点是简单，缺点是理解起来比传统的类－实例模型要困难，最大的缺点是继承的实现需要编写大量代码，并且需要正确实现原型链。 有没有更简单的写法？有！ 新的关键字class从ES6开始正式被引入到JavaScript中。class的目的就是让定义类更简单。 我们先回顾用函数实现Student的方法： function Student(name) { this.name = name; } Student.prototype.hello = function () { alert('Hello, ' + this.name + '!'); } 如果用新的class关键字来编写Student: class Student { constructor(name) { this.name = name; } hello() { alert('Hello, ' + this.name + '!'); } } 比较一下就可以发现，class的定义包含了构造函数constructor和定义在原型对象上的函数hello()（注意没有function关键字），这样就避免了Student.prototype.hello = function () {...}这样分散的代码。 最后，创建一个Student对象代码和前面章节完全一样： var xiaoming = new Student('小明'); xiaoming.hello(); class继承 用class定义对象的另一个巨大的好处是继承更方便了。想一想我们从Student派生一个PrimaryStudent需要编写的代码量。现在，原型继承的中间对象，原型对象的构造函数等等都不需要考虑了，直接通过extends来实现： class PrimaryStudent extends Student { constructor(name, grade) { super(name); // 记得用super调用父类的构造方法! this.grade = grade; } myGrade() { alert('I am at grade ' + this.grade); } } 注意PrimaryStudent的定义也是class关键字实现的，而extends则表示原型链对象来自Student。子类的构造函数可能会与父类不太相同，例如，PrimaryStudent需要name和grade两个参数，并且需要通过super(name)来调用父类的构造函数，否则父类的name属性无法正常初始化。 PrimaryStudent已经自动获得了父类Student的hello方法，我们又在子类中定义了新的myGrade方法。 ES6引入的class和原有的JavaScript原型继承有什么区别呢？实际上它们没有任何区别，class的作用就是让JavaScript引擎去实现原来需要我们自己编写的原型链代码。简而言之，用class的好处就是极大地简化了原型链代码。 你一定会问，class这么好用，能不能现在就用上？ 现在用还早了点，因为不是所有的主流浏览器都支持ES6的class。如果一定要现在就用上，就需要一个工具把class代码转换为传统的prototype代码，可以试试Babel这个工具。 "},"浏览器/浏览器.html":{"url":"浏览器/浏览器.html","title":"浏览器","keywords":"","body":"浏览器 由于JavaScript的出现就是为了能在浏览器中运行，所以，浏览器自然是JavaScript开发者必须要关注的。 目前主流的浏览器分这么几种： IE 6~11：国内用得最多的IE浏览器，历来对W3C标准支持差。从IE10开始支持ES6标准； Chrome：Google出品的基于Webkit内核浏览器，内置了非常强悍的JavaScript引擎——V8。由于Chrome一经安装就时刻保持自升级，所以不用管它的版本，最新版早就支持ES6了； Safari：Apple的Mac系统自带的基于Webkit内核的浏览器，从OS X 10.7 Lion自带的6.1版本开始支持ES6，目前最新的OS X 10.11 El Capitan自带的Safari版本是9.x，早已支持ES6； Firefox：Mozilla自己研制的Gecko内核和JavaScript引擎OdinMonkey。早期的Firefox按版本发布，后来终于聪明地学习Chrome的做法进行自升级，时刻保持最新； 移动设备上目前iOS和Android两大阵营分别主要使用Apple的Safari和Google的Chrome，由于两者都是Webkit核心，结果HTML5首先在手机上全面普及（桌面绝对是Microsoft拖了后腿），对JavaScript的标准支持也很好，最新版本均支持ES6。 其他浏览器如Opera等由于市场份额太小就被自动忽略了。 另外还要注意识别各种国产浏览器，如某某安全浏览器，某某旋风浏览器，它们只是做了一个壳，其核心调用的是IE，也有号称同时支持IE和Webkit的“双核”浏览器。 不同的浏览器对JavaScript支持的差异主要是，有些API的接口不一样，比如AJAX，File接口。对于ES6标准，不同的浏览器对各个特性支持也不一样。 在编写JavaScript的时候，就要充分考虑到浏览器的差异，尽量让同一份JavaScript代码能运行在不同的浏览器中。 "},"浏览器/浏览器对象.html":{"url":"浏览器/浏览器对象.html","title":"浏览器对象","keywords":"","body":"浏览器对象 JavaScript可以获取浏览器提供的很多对象，并进行操作。 window window对象不但充当全局作用域，而且表示浏览器窗口。 window对象有innerWidth和innerHeight属性，可以获取浏览器窗口的内部宽度和高度。内部宽高是指除去菜单栏、工具栏、边框等占位元素后，用于显示网页的净宽高。 兼容性：IE 对应的，还有一个outerWidth和outerHeight属性，可以获取浏览器窗口的整个宽高。 navigator navigator对象表示浏览器的信息，最常用的属性包括： navigator.appName：浏览器名称； navigator.appVersion：浏览器版本； navigator.language：浏览器设置的语言； navigator.platform：操作系统类型； navigator.userAgent：浏览器设定的User-Agent字符串。 请注意，navigator的信息可以很容易地被用户修改，所以JavaScript读取的值不一定是正确的。很多初学者为了针对不同浏览器编写不同的代码，喜欢用if判断浏览器版本，例如： var width; if (getIEVersion(navigator.userAgent) 但这样既可能判断不准确，也很难维护代码。正确的方法是充分利用JavaScript对不存在属性返回undefined的特性，直接用短路运算符||计算： var width = window.innerWidth || document.body.clientWidth; screen screen对象表示屏幕的信息，常用的属性有： screen.width：屏幕宽度，以像素为单位； screen.height：屏幕高度，以像素为单位； screen.colorDepth：返回颜色位数，如8、16、24。 location location对象表示当前页面的URL信息。例如，一个完整的URL： http://www.example.com:8080/path/index.html?a=1&b=2#TOP 可以用location.href获取。要获得URL各个部分的值，可以这么写： location.protocol; // 'http' location.host; // 'www.example.com' location.port; // '8080' location.pathname; // '/path/index.html' location.search; // '?a=1&b=2' location.hash; // 'TOP' document document对象表示当前页面。由于HTML在浏览器中以DOM形式表示为树形结构，document对象就是整个DOM树的根节点。 document的title属性是从HTML文档中的xxx读取的，但是可以动态改变： document.title = '努力学习JavaScript!'; 要查找DOM树的某个节点，需要从document对象开始查找。最常用的查找是根据ID和Tag Name。 我们先准备HTML数据： 摩卡 热摩卡咖啡 酸奶 北京老酸奶 果汁 鲜榨苹果汁 用document对象提供的getElementById()和getElementsByTagName()可以按ID获得一个DOM节点和按Tag名称获得一组DOM节点： var menu = document.getElementById('drink-menu'); var drinks = document.getElementsByTagName('dt'); var i, s; s = '提供的饮料有:'; for (i=0; i document对象还有一个cookie属性，可以获取当前页面的Cookie。 Cookie是由服务器发送的key-value标示符。因为HTTP协议是无状态的，但是服务器要区分到底是哪个用户发过来的请求，就可以用Cookie来区分。当一个用户成功登录后，服务器发送一个Cookie给浏览器，例如user=ABC123XYZ(加密的字符串)...，此后，浏览器访问该网站时，会在请求头附上这个Cookie，服务器根据Cookie即可区分出用户。 Cookie还可以存储网站的一些设置，例如，页面显示的语言等等。 history history对象保存了浏览器的历史记录，JavaScript可以调用history对象的back()或forward ()，相当于用户点击了浏览器的“后退”或“前进”按钮。 这个对象属于历史遗留对象，对于现代Web页面来说，由于大量使用AJAX和页面交互，简单粗暴地调用history.back()可能会让用户感到非常愤怒。 新手开始设计Web页面时喜欢在登录页登录成功时调用history.back()，试图回到登录前的页面。这是一种错误的方法。 任何情况，你都不应该使用history这个对象了。 "},"浏览器/操作DOM.html":{"url":"浏览器/操作DOM.html","title":"操作DOM","keywords":"","body":"操作DOM 由于HTML文档被浏览器解析后就是一棵DOM树，要改变HTML的结构，就需要通过JavaScript来操作DOM。 始终记住DOM是一个树形结构。操作一个DOM节点实际上就是这么几个操作： 更新：更新该DOM节点的内容，相当于更新了该DOM节点表示的HTML的内容； 遍历：遍历该DOM节点下的子节点，以便进行进一步操作； 添加：在该DOM节点下新增一个子节点，相当于动态增加了一个HTML节点； 删除：将该节点从HTML中删除，相当于删掉了该DOM节点的内容以及它包含的所有子节点。 在操作一个DOM节点前，我们需要通过各种方式先拿到这个DOM节点。最常用的方法是document.getElementById()和document.getElementsByTagName()，以及CSS选择器document.getElementsByClassName()。 由于ID在HTML文档中是唯一的，所以document.getElementById()可以直接定位唯一的一个DOM节点。document.getElementsByTagName()和document.getElementsByClassName()总是返回一组DOM节点。要精确地选择DOM，可以先定位父节点，再从父节点开始选择，以缩小范围。 // 返回ID为'test'的节点： var test = document.getElementById('test'); // 先定位ID为'test-table'的节点，再返回其内部所有tr节点： var trs = document.getElementById('test-table').getElementsByTagName('tr'); // 先定位ID为'test-div'的节点，再返回其内部所有class包含red的节点： var reds = document.getElementById('test-div').getElementsByClassName('red'); // 获取节点test下的所有直属子节点: var cs = test.children; // 获取节点test下第一个、最后一个子节点： var first = test.firstElementChild; var last = test.lastElementChild; 第二种方法是使用querySelector()和querySelectorAll()，需要了解selector语法，然后使用条件来获取节点，更加方便： // 通过querySelector获取ID为q1的节点： var q1 = document.querySelector('#q1'); // 通过querySelectorAll获取q1节点内的符合条件的所有节点： var ps = q1.querySelectorAll('div.highlighted > p'); 注意：低版本的IEquerySelector和querySelectorAll。IE8仅有限支持。 严格地讲，我们这里的DOM节点是指Element，但是DOM节点实际上是Node，在HTML中，Node包括Element、Comment、CDATA_SECTION等很多种，以及根节点Document类型，但是，绝大多数时候我们只关心Element，也就是实际控制页面结构的Node，其他类型的Node忽略即可。根节点Document已经自动绑定为全局变量document。 "},"浏览器/更新DOM.html":{"url":"浏览器/更新DOM.html","title":"更新DOM","keywords":"","body":"更新DOM 拿到一个DOM节点后，我们可以对它进行更新。 可以直接修改节点的文本，方法有两种： 一种是修改innerHTML属性，这个方式非常强大，不但可以修改一个DOM节点的文本内容，还可以直接通过HTML片段修改DOM节点内部的子树： // 获取... var p = document.getElementById('p-id'); // 设置文本为abc: p.innerHTML = 'ABC'; // ABC // 设置HTML: p.innerHTML = 'ABC RED XYZ'; // ...的内部结构已修改 用innerHTML时要注意，是否需要写入HTML。如果写入的字符串是通过网络拿到了，要注意对字符编码来避免XSS攻击。 第二种是修改innerText或textContent属性，这样可以自动对字符串进行HTML编码，保证无法设置任何HTML标签： // 获取... var p = document.getElementById('p-id'); // 设置文本: p.innerText = 'alert(\"Hi\")'; // HTML被自动编码，无法设置一个节点: // &lt;script&gt;alert(\"Hi\")&lt;/script&gt; 两者的区别在于读取属性时，innerText不返回隐藏元素的文本，而textContent返回所有文本。另外注意IEtextContent。 修改CSS也是经常需要的操作。DOM节点的style属性对应所有的CSS，可以直接获取或设置。因为CSS允许font-size这样的名称，但它并非JavaScript有效的属性名，所以需要在JavaScript中改写为驼峰式命名fontSize： // 获取... var p = document.getElementById('p-id'); // 设置CSS: p.style.color = '#ff0000'; p.style.fontSize = '20px'; p.style.paddingTop = '2em'; "},"浏览器/插入DOM.html":{"url":"浏览器/插入DOM.html","title":"插入DOM","keywords":"","body":"插入DOM 当我们获得了某个DOM节点，想在这个DOM节点内插入新的DOM，应该如何做？ 如果这个DOM节点是空的，例如，，那么，直接使用innerHTML = 'child'就可以修改DOM节点的内容，相当于“插入”了新的DOM节点。 如果这个DOM节点不是空的，那就不能这么做，因为innerHTML会直接替换掉原来的所有子节点。 有两个办法可以插入新的节点。一个是使用appendChild，把一个子节点添加到父节点的最后一个子节点。例如： JavaScript Java Python Scheme 把JavaScript添加到的最后一项： var js = document.getElementById('js'); var list = document.getElementById('list'); list.appendChild(js); 现在，HTML结构变成了这样： Java Python Scheme JavaScript 因为我们插入的js节点已经存在于当前的文档树，因此这个节点首先会从原先的位置删除，再插入到新的位置。 更多的时候我们会从零创建一个新的节点，然后插入到指定位置： var list = document.getElementById('list'); var haskell = document.createElement('p'); haskell.id = 'haskell'; haskell.innerText = 'Haskell'; list.appendChild(haskell); 这样我们就动态添加了一个新的节点： Java Python Scheme Haskell insertBefore 如果我们要把子节点插入到指定的位置怎么办？可以使用parentElement.insertBefore(newElement, referenceElement);，子节点会插入到referenceElement之前。 还是以上面的HTML为例，假定我们要把Haskell插入到Python之前： Java Python Scheme 可以这么写： var list = document.getElementById('list'); var ref = document.getElementById('python'); var haskell = document.createElement('p'); haskell.id = 'haskell'; haskell.innerText = 'Haskell'; list.insertBefore(haskell, ref); 新的HTML结构如下： Java Haskell Python Scheme "},"浏览器/删除DOM.html":{"url":"浏览器/删除DOM.html","title":"删除DOM","keywords":"","body":"删除DOM 删除一个DOM节点就比插入要容易得多。 要删除一个节点，首先要获得该节点本身以及它的父节点，然后，调用父节点的removeChild把自己删掉： // 拿到待删除节点: var self = document.getElementById('to-be-removed'); // 拿到父节点: var parent = self.parentElement; // 删除: var removed = parent.removeChild(self); removed === self; // true 注意到删除后的节点虽然不在文档树中了，但其实它还在内存中，可以随时再次被添加到别的位置。 当你遍历一个父节点的子节点并进行删除操作时，要注意，children属性是一个只读属性，并且它在子节点变化时会实时更新。 例如，对于如下HTML结构： First Second 当我们用如下代码删除子节点时： var parent = document.getElementById('parent'); parent.removeChild(parent.children[0]); parent.removeChild(parent.children[1]); // 浏览器报错：parent.children[1]不是一个有效的节点。原因就在于，当First节点被删除后，parent.children的节点数量已经从2变为了1，索引[1]已经不存在了。 因此，删除多个节点时，要注意children属性时刻都在变化。 "},"浏览器/操作表单.html":{"url":"浏览器/操作表单.html","title":"操作表单","keywords":"","body":"操作表单 用JavaScript操作表单和操作DOM是类似的，因为表单本身也是DOM树。 不过表单的输入框、下拉框等可以接收用户输入，所以用JavaScript来操作表单，可以获得用户输入的内容，或者对一个输入框设置新的内容。 HTML表单的输入控件主要有以下几种： 文本框，对应的，用于输入文本； 口令框，对应的，用于输入口令； 单选框，对应的，用于选择一项； 复选框，对应的，用于选择多项； 下拉框，对应的，用于选择一项； 隐藏文本，对应的，用户不可见，但表单提交时会把隐藏文本发送到服务器。 获取值 如果我们获得了一个节点的引用，就可以直接调用value获得对应的用户输入值： // var input = document.getElementById('email'); input.value; // '用户输入的值' 这种方式可以应用于text、password、hidden以及select。但是，对于单选框和复选框，value属性返回的永远是HTML预设的值，而我们需要获得的实际是用户是否“勾上了”选项，所以应该用checked判断： // Monday // Tuesday var mon = document.getElementById('monday'); var tue = document.getElementById('tuesday'); mon.value; // '1' tue.value; // '2' mon.checked; // true或者false tue.checked; // true或者false 设置值 设置值和获取值类似，对于text、password、hidden以及select，直接设置value就可以： // var input = document.getElementById('email'); input.value = 'test@example.com'; // 文本框的内容已更新 HTML5控件 HTML5新增了大量标准控件，常用的包括date、datetime、datetime-local、color等，它们都使用标签： 不支持HTML5的浏览器无法识别新的控件，会把它们当做type=\"text\"来显示。支持HTML5的浏览器将获得格式化的字符串。例如，type=\"date\"类型的input的value将保证是一个有效的YYYY-MM-DD格式的日期，或者空字符串。 "},"浏览器/操作文件.html":{"url":"浏览器/操作文件.html","title":"操作文件","keywords":"","body":"操作文件 "}}