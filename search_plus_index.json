{"./":{"url":"./","title":"Introduction","keywords":"","body":"供个人JavaScript学习 "},"基础/基础.html":{"url":"基础/基础.html","title":"基础","keywords":"","body":"基础 "},"基础/变量.html":{"url":"基础/变量.html","title":"变量","keywords":"","body":"变量 字符串 数字 布尔 数组 对象 Undefined 和 null // 未定义类型 var x ; // 数字类型 var y = 5; // 字符串类型 双引号或者单引号均可 var k = 'john'; var a = 123e5; // 布尔类型 var b = true; // 数组类型 var cars = []; cars[0] = \"Saab\"; cars[2] = \"Volvo\"; // 对象类型 var person = {name:\"veng\",age:22}; var name = person.name; var name2 = person[\"name\"]; "},"基础/字符串.html":{"url":"基础/字符串.html","title":"字符串","keywords":"","body":"字符串 JavaScript的字符串就是用''或\"\"括起来的字符表示。 如果'本身也是一个字符，那就可以用\"\"括起来，比如\"I'm OK\"包含的字符是I，'，m，空格，O，K这6个字符。 如果字符串内部既包含'又包含\"怎么办？可以用转义字符\\来标识，比如： var hello = \"I\\'m \\\"OK\\\"\"; hello => I'm \"OK\" ASCII字符可以以\\x##形式的十六进制表示，例如： var a = \"\\x61\"; a => a 61是97的16进制表示 还可以用\\u####表示一个Unicode字符： // 貌似是 UTF-16码位 var b = \"\\u4F60\\u597D\"; b => 你好 多行字符串，由于多行字符串用\\n写起来比较费事，所以最新的ES6标准新增了一种多行字符串的表示方法，用反引号 ` 表示 var c = `first second third`; c => first second third 模板字符串，跟其他语言一样，直接用 + 号连接。 var d = \"world\"; var e = \"hello \"+d; e => hello world 如果有很多变量需要连接，用+号就比较麻烦。ES6新增了一种模板字符串，表示方法和上面的多行字符串一样，用反引号`，但是它会自动替换字符串中的变量： var d = \"world\"; // 注意这里用反引号 var f = `hello ${d}`; f => hello world 字符串的常见方法： var h = \"hello world\"; // 获取字符串的长度 var length = h.length; // 字符串可以看作是数组 var index = h[2]; /* * 需要特别注意的是，字符串是不可变的， * 如果对字符串的某个索引赋值， * 不会有任何错误，但是，也没有任何效果： **/ h[1] = 'k'; /* indexOf()会搜索指定字符串出现的位置, 没有找到指定的子串，返回-1 */ var k = h.indexOf(\"world\"); /* substring()返回指定索引区间的子串： 跟java语法差不多 */ var sub = h.substring(0,2); length => 11 index => \"e\" h[1] => \"e\" k => 6 sub => \"he\" "},"基础/数组.html":{"url":"基础/数组.html","title":"数组","keywords":"","body":"数组 JavaScript的Array可以包含任意数据类型，并通过索引来访问每个元素。 var array = [0.1,'a',false,null]; // 通过length获取数组的长度 var length = array.length; /* 之前在字符串那里提过，索引字符串的某个字符, 不同的是，它对索引赋值,array的值会发生变化 */ array[1] = \"b\"; /* 对数组的长度直接赋值,数组的长度也会相应变化 如下面的,array的长度已变为 6, 后面的以 undefined 填充, 如果修改的length 比原来的更短, 则把多余的元素去掉 */ array.length = 6; // 如果通过索引赋值时，索引超过了范围，同样会引起Array大小的变化： array[7] = 7; array => [0.1,'b',false,null] 赋值后 大多数其他编程语言不允许直接改变数组的大小，越界访问索引会报错。然而，JavaScript的Array却不会有任何错误。在编写代码时，不建议直接修改Array的大小，访问索引时要确保索引不会越界。 Array 的常用方法 indexOf 与String类似，Array也可以通过indexOf()来搜索一个指定的元素的位置 slice slice()就是对应String的substring()版本，它截取Array的部分元素，然后返回一个新的Array, 如果不给slice()传递任何参数，它就会从头到尾截取所有元素。利用这一点，我们可以很容易地复制一个Array var arr = ['A', 'B', 'C', 'D', 'E', 'F', 'G']; arr.slice(0, 3); // 从索引0开始，到索引3结束，但不包括索引3: ['A', 'B', 'C'] arr.slice(3); // 从索引3开始到结束: ['D', 'E', 'F', 'G'] var arr = ['A', 'B', 'C', 'D', 'E', 'F', 'G']; var aCopy = arr.slice(); aCopy === arr; // false push 和pop push()向Array的末尾添加若干元素，pop()则把Array的最后一个元素删除掉： var arr = [1, 2]; arr.push('A', 'B'); // 返回Array新的长度: 4 arr; // [1, 2, 'A', 'B'] arr.pop(); // pop()返回'B' arr; // [1, 2, 'A'] arr.pop(); arr.pop(); arr.pop(); // 连续pop 3次 arr; // [] arr.pop(); // 空数组继续pop不会报错，而是返回undefined arr; // [] unshift 和 shift 如果要往Array的头部添加若干元素，使用unshift()方法，shift()方法则把Array的第一个元素删掉： var arr = [1, 2]; arr.unshift('A', 'B'); // 返回Array新的长度: 4 arr; // ['A', 'B', 1, 2] arr.shift(); // 'A' arr; // ['B', 1, 2] arr.shift(); arr.shift(); arr.shift(); // 连续shift 3次 arr; // [] arr.shift(); // 空数组继续shift不会报错，而是返回undefined arr; // [] sort sort()可以对当前Array进行排序，它会直接修改当前Array的元素位置，直接调用时，按照默认顺序排序: var arr = ['B', 'C', 'A']; arr.sort(); arr; // ['A', 'B', 'C'] reverse reverse()把整个Array的元素给掉个个，也就是反转： var arr = ['one', 'two', 'three']; arr.reverse(); arr; // ['three', 'two', 'one'] splice splice()方法是修改Array的“万能方法”，它可以从指定的索引开始删除若干元素，然后再从该位置添加若干元素： var arr = ['Microsoft', 'Apple', 'Yahoo', 'AOL', 'Excite', 'Oracle']; // 从索引2开始删除3个元素,然后再添加两个元素: arr.splice(2, 3, 'Google', 'Facebook'); // 返回删除的元素 ['Yahoo', 'AOL', 'Excite'] arr; // ['Microsoft', 'Apple', 'Google', 'Facebook', 'Oracle'] // 只删除,不添加: arr.splice(2, 2); // ['Google', 'Facebook'] arr; // ['Microsoft', 'Apple', 'Oracle'] // 只添加,不删除: arr.splice(2, 0, 'Google', 'Facebook'); // 返回[],因为没有删除任何元素 arr; // ['Microsoft', 'Apple', 'Google', 'Facebook', 'Oracle'] join join()方法是一个非常实用的方法，它把当前Array的每个元素都用指定的字符串连接起来，然后返回连接后的字符串： var arr = ['A', 'B', 'C', 1, 2, 3]; arr.join('-'); // 'A-B-C-1-2-3' 如果Array的元素不是字符串，将自动转换为字符串后再连接。 "},"基础/函数.html":{"url":"基础/函数.html","title":"函数","keywords":"","body":"函数 "},"基础/函数1.html":{"url":"基础/函数1.html","title":"函数定义调用","keywords":"","body":"函数 定义函数 在JavaScript中，定义函数的方式如下： function abs(x) { if (x >= 0) { return x; } else { return -x; } } 请注意，函数体内部的语句在执行时，一旦执行到return时，函数就执行完毕，并将结果返回。因此，函数内部通过条件判断和循环可以实现非常复杂的逻辑。 如果没有return语句，函数执行完毕后也会返回结果，只是结果为undefined。 由于JavaScript的函数也是一个对象，上述定义的abs()函数实际上是一个函数对象，而函数名abs可以视为指向该函数的变量。 因此，第二种定义函数的方式如下： var abs = function (x) { if (x >= 0) { return x; } else { return -x; } }; 在这种方式下，function (x) { ... }是一个匿名函数，它没有函数名。但是，这个匿名函数赋值给了变量abs，所以，通过变量abs就可以调用该函数。 上述两种定义完全等价，注意第二种方式按照完整语法需要在函数体末尾加一个;，表示赋值语句结束。 调用函数 由于JavaScript允许传入任意个参数而不影响调用，因此传入的参数比定义的参数多也没有问题，虽然函数内部并不需要这些参数： abs(10, 'blablabla'); // 返回10 abs(-9, 'haha', 'hehe', null); // 返回9 传入的参数比定义的少也没有问题： abs(); // 返回NaN 此时abs(x)函数的参数x将收到undefined，计算结果为NaN。 要避免收到undefined，可以对参数进行检查： function abs(x) { if (typeof x !== 'number') { throw 'Not a number'; } if (x >= 0) { return x; } else { return -x; } } arguments JavaScript还有一个免费赠送的关键字arguments，它只在函数内部起作用，并且永远指向当前函数的调用者传入的所有参数。arguments类似Array但它不是一个Array： function foo(x) { console.log('x = ' + x); // 10 for (var i=0; i x = 10 arg 0 = 10 arg 1 = 20 arg 2 = 30 实际上arguments最常用于判断传入参数的个数。你可能会看到这样的写法： // foo(a[, b], c) // 接收2~3个参数，b是可选参数，如果只传2个参数，b默认为null： function foo(a, b, c) { if (arguments.length === 2) { // 实际拿到的参数是a和b，c为undefined c = b; // 把b赋给c b = null; // b变为默认值 } // ... } rest参数 由于JavaScript函数允许接收任意个参数，于是我们就不得不用arguments来获取所有参数： function foo(a, b) { var i, rest = []; if (arguments.length > 2) { for (i = 2; i 为了获取除了已定义参数a、b之外的参数，我们不得不用arguments，并且循环要从索引2开始以便排除前两个参数，这种写法很别扭，只是为了获得额外的rest参数，有没有更好的方法？ ES6标准引入了rest参数，上面的函数可以改写为： function foo(a, b, ...rest) { console.log('a = ' + a); console.log('b = ' + b); console.log(rest); } foo(1, 2, 3, 4, 5); // 结果: // a = 1 // b = 2 // Array [ 3, 4, 5 ] foo(1); // 结果: // a = 1 // b = undefined // Array [] rest参数只能写在最后，前面用...标识，从运行结果可知，传入的参数先绑定a、b，多余的参数以数组形式交给变量rest，所以，不再需要arguments我们就获取了全部参数。 如果传入的参数连正常定义的参数都没填满，也不要紧，rest参数会接收一个空数组（注意不是undefined）。 "},"基础/函数2.html":{"url":"基础/函数2.html","title":"变量作用域与解构赋值","keywords":"","body":"变量作用域与解构赋值 局部作用域 由于JavaScript的变量作用域实际上是函数内部，我们在for循环等语句块中是无法定义具有局部作用域的变量的： 'use strict'; function foo() { for (var i=0; i 为了解决块级作用域，ES6引入了新的关键字let，用let替代var可以申明一个块级作用域的变量： 'use strict'; function foo() { var sum = 0; for (let i=0; i 常量 由于var和let申明的是变量，如果要申明一个常量，在ES6之前是不行的，我们通常用全部大写的变量来表示“这是一个常量，不要修改它的值”： var PI = 3.14; ES6标准引入了新的关键字const来定义常量，const与let都具有块级作用域： 'use strict'; const PI = 3.14; PI = 3; // 某些浏览器不报错，但是无效果！ PI; // 3.14 解构赋值 从ES6开始，JavaScript引入了解构赋值，可以同时对一组变量进行赋值。 什么是解构赋值？我们先看看传统的做法，如何把一个数组的元素分别赋值给几个变量： var array = ['hello', 'JavaScript', 'ES6']; var x = array[0]; var y = array[1]; var z = array[2]; 现在，在ES6中，可以使用解构赋值，直接对多个变量同时赋值： // 如果浏览器支持解构赋值就不会报错: var [x, y, z] = ['hello', 'JavaScript', 'ES6']; 注意，对数组元素进行解构赋值时，多个变量要用[...]括起来。 如果数组本身还有嵌套，也可以通过下面的形式进行解构赋值，注意嵌套层次和位置要保持一致： let [x, [y, z]] = ['hello', ['JavaScript', 'ES6']]; x; // 'hello' y; // 'JavaScript' z; // 'ES6' 解构赋值还可以忽略某些元素： let [, , z] = ['hello', 'JavaScript', 'ES6']; // 忽略前两个元素，只对z赋值第三个元素 z; // 'ES6' 对一个对象进行解构赋值时，同样可以直接对嵌套的对象属性进行赋值，只要保证对应的层次是一致的： var person = { name: '小明', age: 20, gender: 'male', passport: 'G-12345678', school: 'No.4 middle school', address: { city: 'Beijing', street: 'No.1 Road', zipcode: '100001' } }; var {name, address: {city, zip}} = person; name; // '小明' city; // 'Beijing' zip; // undefined, 因为属性名是zipcode而不是zip // 注意: address不是变量，而是为了让city和zip获得嵌套的address对象的属性: address; // Uncaught ReferenceError: address is not defined 使用解构赋值对对象属性进行赋值时，如果对应的属性不存在，变量将被赋值为undefined，这和引用一个不存在的属性获得undefined是一致的。如果要使用的变量名和属性名不一致，可以用下面的语法获取： var person = { name: '小明', age: 20, gender: 'male', passport: 'G-12345678', school: 'No.4 middle school' }; // 把passport属性赋值给变量id: let {name, passport:id} = person; name; // '小明' id; // 'G-12345678' // 注意: passport不是变量，而是为了让变量id获得passport属性: passport; // Uncaught ReferenceError: passport is not defined 解构赋值还可以使用默认值，这样就避免了不存在的属性返回undefined的问题： var person = { name: '小明', age: 20, gender: 'male', passport: 'G-12345678' }; // 如果person对象没有single属性，默认赋值为true: var {name, single=true} = person; name; // '小明' single; // true 有些时候，如果变量已经被声明了，再次赋值的时候，正确的写法也会报语法错误： // 声明变量: var x, y; // 解构赋值: {x, y} = { name: '小明', x: 100, y: 200}; // 语法错误: Uncaught SyntaxError: Unexpected token = 这是因为JavaScript引擎把{开头的语句当作了块处理，于是=不再合法。解决方法是用小括号括起来： ({x, y} = { name: '小明', x: 100, y: 200}); 使用场景 解构赋值在很多时候可以大大简化代码。例如，交换两个变量x和y的值，可以这么写，不再需要临时变量： var x=1, y=2; [x, y] = [y, x] 快速获取当前页面的域名和路径： var {hostname:domain, pathname:path} = location; 如果一个函数接收一个对象作为参数，那么，可以使用解构直接把对象的属性绑定到变量中。例如，下面的函数可以快速创建一个Date对象： function buildDate({year, month, day, hour=0, minute=0, second=0}) { return new Date(year + '-' + month + '-' + day + ' ' + hour + ':' + minute + ':' + second); } 它的方便之处在于传入的对象只需要year、month和day这三个属性： buildDate({ year: 2017, month: 1, day: 1 }); // Sun Jan 01 2017 00:00:00 GMT+0800 (CST) 也可以传入hour、minute和second属性： buildDate({ year: 2017, month: 1, day: 1, hour: 20, minute: 15 }); // Sun Jan 01 2017 20:15:00 GMT+0800 (CST) 使用解构赋值可以减少代码量，但是，需要在支持ES6解构赋值特性的现代浏览器中才能正常运行。目前支持解构赋值的浏览器包括Chrome，Firefox，Edge等。 "},"基础/函数3.html":{"url":"基础/函数3.html","title":"方法函数","keywords":"","body":"方法 在一个对象中绑定函数，称为这个对象的方法。 在JavaScript中，对象的定义是这样的： var xiaoming = { name: '小明', birth: 1990 }; 但是，如果我们给xiaoming绑定一个函数，就可以做更多的事情。比如，写个age()方法，返回xiaoming的年龄： var xiaoming = { name: '小明', birth: 1990, age: function () { var y = new Date().getFullYear(); return y - this.birth; } }; xiaoming.age; // function xiaoming.age() xiaoming.age(); // 今年调用是25,明年调用就变成26了 绑定到对象上的函数称为方法，和普通函数也没啥区别，但是它在内部使用了一个this关键字，这个东东是什么？ 在一个方法内部，this是一个特殊变量，它始终指向当前对象，也就是xiaoming这个变量。所以，this.birth可以拿到xiaoming的birth属性。 让我们拆开写： function getAge() { var y = new Date().getFullYear(); return y - this.birth; } var xiaoming = { name: '小明', birth: 1990, age: getAge }; xiaoming.age(); // 25, 正常结果 getAge(); // NaN 单独调用函数getAge()怎么返回了NaN？请注意，我们已经进入到了JavaScript的一个大坑里。 JavaScript的函数内部如果调用了this，那么这个this到底指向谁？ 答案是，视情况而定！ 如果以对象的方法形式调用，比如xiaoming.age()，该函数的this指向被调用的对象，也就是xiaoming，这是符合我们预期的。 如果单独调用函数，比如getAge()，此时，该函数的this指向全局对象，也就是window。 坑爹啊！ 更坑爹的是，如果这么写： var fn = xiaoming.age; // 先拿到xiaoming的age函数 fn(); // NaN 也是不行的！要保证this指向正确，必须用obj.xxx()的形式调用！ 由于这是一个巨大的设计错误，要想纠正可没那么简单。ECMA决定，在strict模式下让函数的this指向undefined，因此，在strict模式下，你会得到一个错误: var xiaoming = { name: '小明', birth: 1990, age: function () { var y = new Date().getFullYear(); return y - this.birth; } }; var fn = xiaoming.age; fn(); // Uncaught TypeError: Cannot read property 'birth' of undefined apply 虽然在一个独立的函数调用中，根据是否是strict模式，this指向undefined或window，不过，我们还是可以控制this的指向的！ 要指定函数的this指向哪个对象，可以用函数本身的apply方法，它接收两个参数，第一个参数就是需要绑定的this变量，第二个参数是Array，表示函数本身的参数。 用apply修复getAge()调用： function getAge() { var y = new Date().getFullYear(); return y - this.birth; } var xiaoming = { name: '小明', birth: 1990, age: getAge }; xiaoming.age(); // 25 getAge.apply(xiaoming, []); // 25, this指向xiaoming, 参数为空 另一个与apply()类似的方法是call()，唯一区别是： apply()把参数打包成Array再传入； call()把参数按顺序传入。 比如调用Math.max(3, 5, 4)，分别用apply()和call()实现如下： Math.max.apply(null, [3, 5, 4]); // 5 Math.max.call(null, 3, 5, 4); // 5 对普通函数调用，我们通常把this绑定为null。 "},"基础/高阶函数.html":{"url":"基础/高阶函数.html","title":"高阶函数","keywords":"","body":"高阶函数 JavaScript的函数其实都指向某个变量。既然变量可以指向函数，函数的参数能接收变量，那么一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数。 一个最简单的高阶函数： function add(x, y, f) { return f(x) + f(y); } "},"基础/map-reduce.html":{"url":"基础/map-reduce.html","title":"map/reduce","keywords":"","body":"map/reduce map 举例说明，比如我们有一个函数f(x)=x2，要把这个函数作用在一个数组[1, 2, 3, 4, 5, 6, 7, 8, 9]上，就可以用map实现如下： 由于map()方法定义在JavaScript的Array中，我们调用Array的map()方法，传入我们自己的函数，就得到了一个新的Array作为结果： function pow(x) { return x * x; } var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]; var results = arr.map(pow); // [1, 4, 9, 16, 25, 36, 49, 64, 81] reduce 再看reduce的用法。Array的reduce()把一个函数作用在这个Array的[x1, x2, x3...]上，这个函数必须接收两个参数，reduce()把结果继续和序列的下一个元素做累积计算，其效果就是： [x1, x2, x3, x4].reduce(f) = f(f(f(x1, x2), x3), x4) 比方说对一个Array求和，就可以用reduce实现： var arr = [1, 3, 5, 7, 9]; arr.reduce(function (x, y) { return x + y; }); // 25 "},"基础/filter.html":{"url":"基础/filter.html","title":"filter","keywords":"","body":"filter filter也是一个常用的操作，它用于把Array的某些元素过滤掉，然后返回剩下的元素。 和map()类似，Array的filter()也接收一个函数。和map()不同的是，filter()把传入的函数依次作用于每个元素，然后根据返回值是true还是false决定保留还是丢弃该元素。 例如： let arr = [1,2,4,5,6,9,10]; // 获取和 let sum = arr.reduce(function (x,y) { return x+y; }); // 获取长度 let length = arr.length; // 取得平均数 let average = sum / length; // 保留大于平均数的数 let r = arr.filter(function (x) { return x > average; });//[ 6, 9, 10 ] 把一个Array中的去空，可以这么写： const array = ['a','','b','','c',null]; const notEmptyArray = array.filter(function (x) { return x && x.trim(); }); // [ 'a', 'b', 'c' ] 利用filter，可以巧妙地去除Array的重复元素： const repeatArray = [1,2,11,2,3,4,1]; let notRepeatArray = repeatArray.filter(function (x, index, self) { return self.indexOf(x) === index; }); // [ 1, 2, 11, 3, 4 ] 筛选素数： const randomArray = []; for (let i = 1; i "},"基础/sort.html":{"url":"基础/sort.html","title":"sort","keywords":"","body":"sort JavaScript的Array的sort()方法就是用于排序的，但是排序结果可能让你大吃一惊： // 看上去正常的结果: ['Google', 'Apple', 'Microsoft'].sort(); // ['Apple', 'Google', 'Microsoft']; // apple排在了最后: ['Google', 'apple', 'Microsoft'].sort(); // ['Google', 'Microsoft\", 'apple'] // 无法理解的结果: [10, 20, 1, 2].sort(); // [1, 10, 2, 20] 第二个排序把apple排在了最后，是因为字符串根据ASCII码进行排序，而小写字母a的ASCII码在大写字母之后。 第三个排序结果是什么鬼？简单的数字排序都能错？ 这是因为Array的sort()方法默认把所有元素先转换为String再排序，结果'10'排在了'2'的前面，因为字符'1'比字符'2'的ASCII码小。 如果不知道sort()方法的默认排序规则，直接对数字排序，绝对栽进坑里！ 幸运的是，sort()方法也是一个高阶函数，它还可以接收一个比较函数来实现自定义的排序。 const numberArray = [10,20,1,2]; numberArray.sort(function (x, y) { return x-y; // 返回正数则调换位置 }); // [ 1, 2, 10, 20 ] 对字符串的排序: stringArray.sort(function (x, y) { const upperX = x.toLocaleUpperCase(); const upperY = y.toLocaleUpperCase(); if (upperX upperY){ return 1; }else{ return 0; } }); // [ 'apple', 'Google', 'Microsoft' ] 最后友情提示，sort()方法会直接对Array进行修改，它返回的结果仍是当前Array： var a1 = ['B', 'A', 'C']; var a2 = a1.sort(); a1; // ['A', 'B', 'C'] a2; // ['A', 'B', 'C'] a1 === a2; // true, a1和a2是同一对象 "},"基础/array其他方法.html":{"url":"基础/array其他方法.html","title":"array其他方法","keywords":"","body":"array其他方法 every every()方法可以判断数组的所有元素是否满足测试条件。 例如，给定一个包含若干字符串的数组，判断所有字符串是否满足指定的测试条件： const fruit = ['Apple','pear','orange']; const isMoreThan = fruit.every(function (value) { return value.length > 3; }); // true const isLower = fruit.every(function (value) { return value.toLowerCase() === value; }); // false find find()方法用于查找符合条件的第一个元素，如果找到了，返回这个元素，否则，返回undefined： const fruit = ['Apple','pear','orange']; const findLower = fruit.find(function (value) { return value.toLowerCase() === value; }); // pear const findUpper = fruit.find(function (value) { return value.toUpperCase() === value; }); // undefined findIndex findIndex()和find()类似，也是查找符合条件的第一个元素，不同之处在于findIndex()会返回这个元素的索引，如果没有找到，返回-1. forEach forEach()和map()类似，它也把每个元素依次作用于传入的函数，但不会返回新的数组。forEach()常用于遍历数组，因此，传入的函数不需要返回值： const fruit = ['Apple','pear','orange']; fruit.forEach(function (value) { console.log(value); }); "},"基础/闭包.html":{"url":"基础/闭包.html","title":"闭包","keywords":"","body":"闭包 函数作为返回值 高阶函数除了可以接受函数作为参数外，还可以把函数作为结果值返回。 我们来实现一个对Array的求和。但是，如果不需要立刻求和，而是在后面的代码中，根据需要再计算怎么办？可以不返回求和的结果，而是返回求和的函数！ function lazySum(arr) { return function () { return arr.reduce(function (x, y) { return x+y; }) } } 调用函数f时，才真正计算求和的结果： let f = lazySum([1, 2, 3, 4, 5]); // function sum() 请再注意一点，当我们调用lazySum()时，每次调用都会返回一个新的函数，即使传入相同的参数： let f1= lazySum([1,2,3,4,5]); let f2 = lazySum([1,2,3,4,5]); console.log(f1 === f2); //false 说了这么多，难道闭包就是为了返回一个函数然后延迟执行吗？ 当然不是！闭包有非常强大的功能。举个栗子： 在面向对象的程序设计语言里，比如Java和C++，要在对象内部封装一个私有变量，可以用private修饰一个成员变量。 在没有class机制，只有函数的语言里，借助闭包，同样可以封装一个私有变量。我们用JavaScript创建一个计数器： function create_counter(initial) { let x = initial||0; return { increase(){ x += 1; return x; } } } 它用起来像这样： var c1 = create_counter(); c1.inc(); // 1 c1.inc(); // 2 c1.inc(); // 3 var c2 = create_counter(10); c2.inc(); // 11 c2.inc(); // 12 c2.inc(); // 13 "},"基础/箭头函数.html":{"url":"基础/箭头函数.html","title":"箭头函数","keywords":"","body":"箭头函数 ES6标准新增了一种新的函数：Arrow Function（箭头函数）。 x => x*x; 上面的箭头函数相当于（匿名函数）： function (x) { return x * x; } 那怎么调用，就是将其赋值给变量,如： const pow = x => x * x; console.log(pow(2)); // 4 箭头函数相当于匿名函数，并且简化了函数定义。箭头函数有两种格式，一种像上面的，只包含一个表达式，连{ ... }和return都省略掉了。还有一种可以包含多条语句，这时候就不能省略{ ... }和return 如果参数不是一个，就需要用括号()括起来： // 两个参数: (x, y) => x * x + y * y // 无参数: () => 3.14 // 可变参数: (x, y, ...rest) => { var i, sum = x + y; for (i=0; i 如果要返回一个对象，就要注意，如果是单表达式，这么写的话会报错： // SyntaxError: x => { foo: x } 因为和函数体的{ ... }有语法冲突，所以要改为： // ok: x => ({ foo: x }) this 箭头函数看上去是匿名函数的一种简写，但实际上，箭头函数和匿名函数有个明显的区别：箭头函数内部的this是词法作用域，由上下文确定。 var obj = { birth: 1990, getAge: function (year) { var b = this.birth; // 1990 var fn = (y) => y - this.birth; // this.birth仍是1990 return fn.call({birth:2000}, year); } }; obj.getAge(2015); // 25 便利 如，之前的排序可以： let arr = [10,20,1,2]; arr.sort((x,y)=>x-y); "},"基础/generator.html":{"url":"基础/generator.html","title":"generator","keywords":"","body":"generator generator（生成器）是ES6标准引入的新的数据类型。一个generator看上去像一个函数，但可以返回多次。 函数在执行过程中，如果没有遇到return语句（函数末尾如果没有return，就是隐含的return undefined;），控制权无法交回被调用的代码。 generator和函数不同的是，generator由function*定义（注意多出的*号），并且，除了return语句，还可以用yield返回多次。 我们以一个著名的斐波那契数列为例，它由0，1开头： function* fib(max) { var t, a = 0, b = 1, n = 0; while (n 直接调用一个generator和调用函数不一样，fib(5)仅仅是创建了一个generator对象，还没有去执行它。 调用generator对象有两个方法，一是不断地调用generator对象的next()方法： var f = fib(5); f.next(); // {value: 0, done: false} f.next(); // {value: 1, done: false} f.next(); // {value: 1, done: false} f.next(); // {value: 2, done: false} f.next(); // {value: 3, done: false} f.next(); // {value: undefined, done: true} 要生成一个自增的ID，可以编写一个next_id()函数： function* nextId() { let currentId = 0; while (true){ yield currentId+=1; } } const f = nextId(); console.log(f.next()); console.log(f.next()); "},"基础/标准对象.html":{"url":"基础/标准对象.html","title":"标准对象","keywords":"","body":"标准对象 在JavaScript的世界里，一切都是对象。 但是某些对象还是和其他对象不太一样。为了区分对象的类型，我们用typeof操作符获取对象的类型，它总是返回一个字符串： typeof 123; // 'number' typeof NaN; // 'number' typeof 'str'; // 'string' typeof true; // 'boolean' typeof undefined; // 'undefined' typeof Math.abs; // 'function' typeof null; // 'object' typeof []; // 'object' typeof {}; // 'object' 可见，number、string、boolean、function和undefined有别于其他类型。特别注意null的类型是object，Array的类型也是object，如果我们用typeof将无法区分出null、Array和通常意义上的object——{}。 包装对象 除了这些类型外，JavaScript还提供了包装对象，熟悉Java的小伙伴肯定很清楚int和Integer这种暧昧关系。 number、boolean和string都有包装对象。没错，在JavaScript中，字符串也区分string类型和它的包装类型。包装对象用new创建： var n = new Number(123); // 123,生成了新的包装类型 var b = new Boolean(true); // true,生成了新的包装类型 var s = new String('str'); // 'str',生成了新的包装类型 虽然包装对象看上去和原来的值一模一样，显示出来也是一模一样，但他们的类型已经变为object了！所以，包装对象和原始值用===比较会返回false： typeof new Number(123); // 'object' new Number(123) === 123; // false typeof new Boolean(true); // 'object' new Boolean(true) === true; // false typeof new String('str'); // 'object' new String('str') === 'str'; // false 所以闲的蛋疼也不要使用包装对象！尤其是针对string类型！！！ 如果我们在使用Number、Boolean和String时，没有写new会发生什么情况？ 此时，Number()、Boolean和String()被当做普通函数，把任何类型的数据转换为number、boolean和string类型（注意不是其包装类型）： var n = Number('123'); // 123，相当于parseInt()或parseFloat() typeof n; // 'number' var b = Boolean('true'); // true typeof b; // 'boolean' var b2 = Boolean('false'); // true! 'false'字符串转换结果为true！因为它是非空字符串！ var b3 = Boolean(''); // false var s = String(123.45); // '123.45' typeof s; // 'string' 总结一下，有这么几条规则需要遵守： 不要使用new Number()、new Boolean()、new String()创建包装对象； 用parseInt()或parseFloat()来转换任意类型到number； 用String()来转换任意类型到string，或者直接调用某个对象的toString()方法； 通常不必把任意类型转换为boolean再判断，因为可以直接写if (myVar) {...}； typeof操作符可以判断出number、boolean、string、function和undefined； 判断Array要使用Array.isArray(arr)； 判断null请使用myVar === null； 判断某个全局变量是否存在用typeof window.myVar === 'undefined'； 函数内部判断某个变量是否存在用typeof myVar === 'undefined'。 任何对象都有toString()方法吗？null和undefined就没有！确实如此，这两个特殊值要除外，虽然null还伪装成了object类型。number对象调用toString()报SyntaxError： const number = 123; console.log(number.toString()); // 123 console.log(123.toString()); // error console.log(123..toString()); // 123 综上，个人认为是，它将 123. 看成是一个小数，然后你直接跟toString()，它不会认为 . 是调用方法，而是看成是数字的一部分。 "},"基础/Date.html":{"url":"基础/Date.html","title":"Date","keywords":"","body":"Date 在JavaScript中，Date对象用来表示日期和时间。 要获取系统当前时间，用： const date = new Date();// 注意要new 否则调用不了方法 console.log(date.toString()); // Sat Aug 31 2019 19:09:13 GMT+0800 (GMT+08:00) console.log(date.getFullYear()); // 2019, 年份 console.log(date.getMonth()); // 7,月份，注意月份范围是0~11，7表示八月 console.log(date.getDate()); // 31号 console.log(date.getDay()); // 6,星期六 console.log(date.getHours()); // 18,时 console.log(date.getMinutes()); // 52,分 console.log(date.getSeconds()); // 24,秒 console.log(date.getMilliseconds()); // 202,毫秒 console.log(date.getTime()); //1567248744202 时间戳 如果要创建一个指定日期和时间的Date对象，可以用： // 获取指定时间 const next = new Date(2020,1,1,1,1,1); console.log(next.toString()); // Sat Feb 01 2020 01:01:01 GMT+0800 (GMT+08:00) 更有意思的是，还能够用来自动更正时间： // 传入一个错误的时间 会自动校正 const errorDate = new Date(2020,1,55,1,1,1); console.log(errorDate.toString()); // Thu Mar 26 2020 01:01:01 GMT+0800 (GMT+08:00) 一定要注意月份的问题，0-11。 第二种创建一个指定日期和时间的方法是解析一个符合ISO 8601格式的字符串： const isoDate = Date.parse('2020-09-23T22:49:22.875+08:00'); console.log(isoDate.toString()); // 1600872562875 但它返回的不是Date对象，而是一个时间戳。不过有时间戳就可以很容易地把它转换为一个Date： const timeStampDate = new Date(1600872562875); console.log(timeStampDate.toString()); // Wed Sep 23 2020 22:49:22 GMT+0800 (GMT+08:00) 时区 Date对象表示的时间总是按浏览器所在时区显示的，不过我们既可以显示本地时间，也可以显示调整后的UTC时间： const localDate = new Date(); // 获取本地时间 console.log(localDate.toLocaleString()); // 2019-8-31 19:21:54 // 获取 UTC 时间 相差8小时 console.log(localDate.toUTCString()); // Sat, 31 Aug 2019 11:21:54 GMT console.log(localDate.toLocaleDateString()); // 2019-8-31 console.log(localDate.toLocaleTimeString()); // 19:21:54 "},"基础/RepExp.html":{"url":"基础/RepExp.html","title":"正则表达式","keywords":"","body":"正则表达式 JS 的正则表达式跟 Java 的正则表达式类似。 用\\d可以匹配一个数字，\\w可以匹配一个字母或数字, .可以匹配任意一个字符。 要匹配变长的字符，在正则表达式中，用*表示任意个字符（包括0个），用+表示至少一个字符，用?表示0个或1个字符，用{n}表示n个字符，用{n,m}表示n-m个字符。 \\s 可以匹配一个空格（包括Tab等空白符）。 要做更精确地匹配，可以用[]表示范围，比如： [0-9a-zA-Z\\_]可以匹配一个数字、字母或者下划线； [0-9a-zA-Z\\_]+可以匹配至少由一个数字、字母或者下划线组成的字符串，比如'a100'，'0_Z'，'js2015'等等； [a-zA-Z\\_\\$][0-9a-zA-Z\\_\\$]*可以匹配由字母或下划线、$开头，后接任意个由一个数字、字母或者下划线、$组成的字符串，也就是JavaScript允许的变量名； [a-zA-Z\\_\\$][0-9a-zA-Z\\_\\$]{0, 19}更精确地限制了变量的长度是1-20个字符（前面1个字符+后面最多19个字符）。 A|B可以匹配A或B，所以(J|j)ava(S|s)cript可以匹配'JavaScript'、'Javascript'、'javaScript'或者'javascript'。 ^表示行的开头，^\\d表示必须以数字开头。 $表示行的结束，\\d$表示必须以数字结束。 你可能注意到了，js也可以匹配'jsp'，但是加上^js$就变成了整行匹配，就只能匹配'js'了。整行匹配就是要全部匹配，不能多也不能少。 const js = /^js$/; console.log(js.test(\"jss\")); // false 切分字符串 用正则表达式切分字符串比用固定的字符更灵活，请看正常的切分代码： 'a b c'.split(' '); // ['a', 'b', '', '', 'c'] 嗯，无法识别连续的空格，用正则表达式试试： 'a b c'.split(/\\s+/); // ['a', 'b', 'c'] 无论多少个空格都可以正常分割。加入,试试： 'a,b, c d'.split(/[\\s\\,]+/); // ['a', 'b', 'c', 'd'] 再加入;试试： 'a,b;; c d'.split(/[\\s\\,\\;]+/); // ['a', 'b', 'c', 'd'] 如果用户输入了一组标签，下次记得用正则表达式来把不规范的输入转化成正确的数组。 分组 除了简单地判断是否匹配之外，正则表达式还有提取子串的强大功能。用()表示的就是要提取的分组（Group）。比如： ^(\\d{3})-(\\d{3,8})$分别定义了两个组，可以直接从匹配的字符串中提取出区号和本地号码： var re = /^(\\d{3})-(\\d{3,8})$/; re.exec('010-12345'); // ['010-12345', '010', '12345'] re.exec('010 12345'); // null 如果正则表达式中定义了组，就可以在RegExp对象上用exec()方法提取出子串来。 exec()方法在匹配成功后，会返回一个Array，第一个元素是正则表达式匹配到的整个字符串，后面的字符串表示匹配成功的子串。 exec()方法在匹配失败时返回null。 贪婪匹配 需要特别指出的是，正则匹配默认是贪婪匹配，也就是匹配尽可能多的字符。举例如下，匹配出数字后面的0： var re = /^(\\d+)(0*)$/; re.exec('102300'); // ['102300', '102300', ''] 由于\\d+采用贪婪匹配，直接把后面的0全部匹配了，结果0*只能匹配空字符串了。 必须让\\d+采用非贪婪匹配（也就是尽可能少匹配），才能把后面的0匹配出来，加个?就可以让\\d+采用非贪婪匹配： var re = /^(\\d+?)(0*)$/; re.exec('102300'); // ['102300', '1023', '00'] 全局搜索 JavaScript的正则表达式还有几个特殊的标志，最常用的是g，表示全局匹配： var r1 = /test/g; // 等价于: var r2 = new RegExp('test', 'g'); 全局匹配可以多次执行exec()方法来搜索一个匹配的字符串。当我们指定g标志后，每次运行exec()，正则表达式本身会更新lastIndex属性，表示上次匹配到的最后索引： var s = 'JavaScript, VBScript, JScript and ECMAScript'; var re=/[a-zA-Z]+Script/g; // 使用全局匹配: re.exec(s); // ['JavaScript'] re.lastIndex; // 10 re.exec(s); // ['VBScript'] re.lastIndex; // 20 re.exec(s); // ['JScript'] re.lastIndex; // 29 re.exec(s); // ['ECMAScript'] re.lastIndex; // 44 re.exec(s); // null，直到结束仍没有匹配到 全局匹配类似搜索，因此不能使用/^...$/，那样只会最多匹配一次。 正则表达式还可以指定i标志，表示忽略大小写，m标志，表示执行多行匹配。 "},"基础/正则表达式.html":{"url":"基础/正则表达式.html","title":"正则表达式别篇","keywords":"","body":"正则表达式 语法 /正则表达式主体/修饰符(可选) 正则表达式主体即正则表达式。 修饰符的话，则有三种，如下： 修饰符 描述 i 执行对大小写不敏感的匹配。 g 执行全局匹配（查找所有匹配而非在找到第一个匹配后停止）。 m 执行多行匹配。 对于字符串而言，正则表达式通常有两个方法：search() 和 replace(),显然前者是检索后者是替换。 现在我们来尝试一下： var str = \"Hello World\"; // i 搜索不区分大小写 返回第一次出现的位置 // 例如：下面检索 第一次出现world的地方 var i = str.search(/WORLD/i); // g 是区分大小写的,并且是全局搜索 var g = str.search(/L/g); // 对于 m 测试发现,用处真的不是很大,g 就可以了 var str2 = \"1\\n 2\\n 3\\n\"; var g2 = str2.search(/2/g); var m2 = str2.search(/2/m); // 替换字符串 var str3 = \"AABB\"; // 仅将第一次出现的 A的替换成 1 var i3 = str3.replace(/a/i,\"1\"); // 既全局匹配又忽略大小写,将所有的A均替换为1,修饰符可以直接拼接,是&的关系 var gi3 = str3.replace(/a/gi,\"1\"); i => 6 g => -1 上面没有大写的L 所以返回 -1 g2 => 3 m2 => 3 str3 => AABB 替换后，原来的字符串是不变的，返回的string才变了 i3 => 1ABB gi3 => 11BB 以上是字符串的方法。 对于正则表达式，JavaScript 里有一个预定义了属性和方法的正则表达式对象 RegExp 。 该对象有两个方法：test() 和 exec(). 现在尝试一下： var rep = /a/i; // 另种写法,new 一个RegExp 对象,也可以省略,用上面的写法也行 // var rep = new RegExp(/a/i); // 该方法会返回一个boolean 类型,如果有符合正则表达式返回true,反之返回false var test = rep.test(\"abcd\"); // 该方法会返回一个数组 var exec = rep.exec(\"abcd\"); test => true exec => [ 'a', index: 0, input: 'abcd' ] "},"基础/json.html":{"url":"基础/json.html","title":"JSON","keywords":"","body":"JSON JSON是JavaScript Object Notation的缩写，它是一种数据交换格式。 在JSON出现之前，大家一直用XML来传递数据。因为XML是一种纯文本格式，所以它适合在网络上交换数据。XML本身不算复杂，但是，加上DTD、XSD、XPath、XSLT等一大堆复杂的规范以后，任何正常的软件开发人员碰到XML都会感觉头大了，最后大家发现，即使你努力钻研几个月，也未必搞得清楚XML的规范。 终于，在2002年的一天，道格拉斯·克罗克福特（Douglas Crockford）同学为了拯救深陷水深火热同时又被某几个巨型软件企业长期愚弄的软件工程师，发明了JSON这种超轻量级的数据交换格式。 道格拉斯同学长期担任雅虎的高级架构师，自然钟情于JavaScript。他设计的JSON实际上是JavaScript的一个子集。在JSON中，一共就这么几种数据类型： number：和JavaScript的number完全一致； boolean：就是JavaScript的true或false； string：就是JavaScript的string； null：就是JavaScript的null； array：就是JavaScript的Array表示方式——[]； object：就是JavaScript的{ ... }表示方式。 以及上面的任意组合。 并且，JSON还定死了字符集必须是UTF-8，表示多语言就没有问题了。为了统一解析，JSON的字符串规定必须用双引号\"\"，Object的键也必须用双引号\"\"。 由于JSON非常简单，很快就风靡Web世界，并且成为ECMA标准。几乎所有编程语言都有解析JSON的库，而在JavaScript中，我们可以直接使用JSON，因为JavaScript内置了JSON的解析。 把任何JavaScript对象变成JSON，就是把这个对象序列化成一个JSON格式的字符串，这样才能够通过网络传递给其他计算机。 如果我们收到一个JSON格式的字符串，只需要把它反序列化成一个JavaScript对象，就可以在JavaScript中直接使用这个对象了。 序列化 const person = { name:\"Tom\", age:\"22\", phone:12345678910 }; const personString = JSON.stringify(person); // {\"name\":\"Tom\",\"age\":\"22\",\"phone\":12345678910} 要输出得好看一些，可以加上参数，按缩进输出： JSON.stringify(person,null,\" \"); { \"name\": \"Tom\", \"age\": \"22\", \"phone\": 12345678910 } 第二个参数用于控制如何筛选对象的键值，如果我们只想输出指定的属性，可以传入Array： JSON.stringify(person,[\"name\",\"age\"],\" \"); "},"基础/面向对象编程.html":{"url":"基础/面向对象编程.html","title":"面向对象编程","keywords":"","body":"面向对象编程 JavaScript的所有数据都可以看成对象，那是不是我们已经在使用面向对象编程了呢？ 当然不是。如果我们只使用Number、Array、string以及基本的{...}定义的对象，还无法发挥出面向对象编程的威力。 JavaScript不区分类和实例的概念，而是通过原型（prototype）来实现面向对象编程。 原型是指当我们想要创建xiaoming这个具体的学生时，我们并没有一个Student类型可用。那怎么办？恰好有这么一个现成的对象: const student = { name:\"Student\", height:1.2, run(){ console.log(this.name + \" is running...\"); } }; const xiaoming = { name: \"小明\" }; xiaoming.__proto__ = student; xiaoming.run(); // 小明 is running... 注意最后一行代码把xiaoming的原型指向了对象Student，看上去xiaoming仿佛是从Student继承下来的. 请注意，上述代码仅用于演示目的。在编写JavaScript代码时，不要直接用obj.__proto__去改变一个对象的原型，并且，低版本的IE也无法使用__proto__。Object.create()方法可以传入一个原型对象，并创建一个基于该原型的新对象，但是新对象什么属性都没有，因此，我们可以编写一个函数来创建xiaoming： // 原型对象: var Student = { name: 'Robot', height: 1.2, run: function () { console.log(this.name + ' is running...'); } }; function createStudent(name) { // 基于Student原型创建一个新对象: var s = Object.create(Student); // 初始化新对象: s.name = name; return s; } var xiaoming = createStudent('小明'); xiaoming.run(); // 小明 is running... xiaoming.__proto__ === Student; // true "},"基础/创建对象.html":{"url":"基础/创建对象.html","title":"创建对象","keywords":"","body":"创建对象 JavaScript对每个创建的对象都会设置一个原型，指向它的原型对象。 当我们用obj.xxx访问一个对象的属性时，JavaScript引擎先在当前对象上查找该属性，如果没有找到，就到其原型对象上找，如果还没有找到，就一直上溯到Object.prototype对象，最后，如果还没有找到，就只能返回undefined。 其原型链是： arr ----> Array.prototype ----> Object.prototype ----> null Array.prototype定义了indexOf()、shift()等方法，因此你可以在所有的Array对象上直接调用这些方法。 当我们创建一个函数时： function foo() { return 0; } 函数也是一个对象，它的原型链是： foo ----> Function.prototype ----> Object.prototype ----> null 由于Function.prototype定义了apply()等方法，因此，所有函数都可以调用apply()方法。 很容易想到，如果原型链很长，那么访问一个对象的属性就会因为花更多的时间查找而变得更慢，因此要注意不要把原型链搞得太长。 构造函数 除了直接用{ ... }创建一个对象外，JavaScript还可以用一种构造函数的方法来创建对象。它的用法是，先定义一个构造函数： function Student(name) { this.name = name; this.hello = function () { alert('Hello, ' + this.name + '!'); } } 你会问，咦，这不是一个普通函数吗？ 这确实是一个普通函数，但是在JavaScript中，可以用关键字new来调用这个函数，并返回一个对象： var xiaoming = new Student('小明'); xiaoming.name; // '小明' xiaoming.hello(); // Hello, 小明! 注意，如果不写new，这就是一个普通函数，它返回undefined。但是，如果写了new，它就变成了一个构造函数，它绑定的this指向新创建的对象，并默认返回this，也就是说，不需要在最后写return this;。 新创建的xiaoming的原型链是： xiaoming ----> Student.prototype ----> Object.prototype ----> null 也就是说，xiaoming的原型指向函数Student的原型。如果你又创建了xiaohong、xiaojun，那么这些对象的原型与xiaoming是一样的： xiaoming ↘ xiaohong -→ Student.prototype ----> Object.prototype ----> null xiaojun ↗ 用new Student()创建的对象还从原型上获得了一个constructor属性，它指向函数Student本身： xiaoming.constructor === Student.prototype.constructor; // true Student.prototype.constructor === Student; // true Object.getPrototypeOf(xiaoming) === Student.prototype; // true xiaoming instanceof Student; // true 看晕了吧？用一张图来表示这些乱七八糟的关系就是： 红色箭头是原型链。注意，Student.prototype指向的对象就是xiaoming、xiaohong的原型对象，这个原型对象自己还有个属性constructor，指向Student函数本身。 另外，函数Student恰好有个属性prototype指向xiaoming、xiaohong的原型对象，但是xiaoming、xiaohong这些对象可没有prototype这个属性，不过可以用__proto__这个非标准用法来查看。 现在我们就认为xiaoming、xiaohong这些对象“继承”自Student。 不过还有一个小问题，注意观察： xiaoming.name; // '小明' xiaohong.name; // '小红' xiaoming.hello; // function: Student.hello() xiaohong.hello; // function: Student.hello() xiaoming.hello === xiaohong.hello; // false xiaoming和xiaohong各自的name不同，这是对的，否则我们无法区分谁是谁了。 xiaoming和xiaohong各自的hello是一个函数，但它们是两个不同的函数，虽然函数名称和代码都是相同的！ 如果我们通过new Student()创建了很多对象，这些对象的hello函数实际上只需要共享同一个函数就可以了，这样可以节省很多内存。 要让创建的对象共享一个hello函数，根据对象的属性查找原则，我们只要把hello函数移动到xiaoming、xiaohong这些对象共同的原型上就可以了，也就是Student.prototype： 修改代码如下： function Student(name) { this.name = name; } Student.prototype.hello = function () { alert('Hello, ' + this.name + '!'); }; 用new创建基于原型的JavaScript的对象就是这么简单！ 我们还可以编写一个createStudent()函数，在内部封装所有的new操作。一个常用的编程模式像这样： function Student(props) { this.name = props.name || '匿名'; // 默认值为'匿名' this.grade = props.grade || 1; // 默认值为1 } Student.prototype.hello = function () { alert('Hello, ' + this.name + '!'); }; function createStudent(props) { return new Student(props || {}) } 这个createStudent()函数有几个巨大的优点：一是不需要new来调用，二是参数非常灵活，可以不传，也可以这么传： var xiaoming = createStudent({ name: '小明' }); xiaoming.grade; // 1 如果创建的对象有很多属性，我们只需要传递需要的某些属性，剩下的属性可以用默认值。由于参数是一个Object，我们无需记忆参数的顺序。如果恰好从JSON拿到了一个对象，就可以直接创建出xiaoming。 "},"基础/原型继承.html":{"url":"基础/原型继承.html","title":"原型继承","keywords":"","body":"原型继承 在传统的基于Class的语言如Java、C++中，继承的本质是扩展一个已有的Class，并生成新的Subclass。 由于这类语言严格区分类和实例，继承实际上是类型的扩展。但是，JavaScript由于采用原型继承，我们无法直接扩展一个Class，因为根本不存在Class这种类型。 但是办法还是有的。我们先回顾Student构造函数： function Student(props) { this.name = props.name || 'Unnamed'; } Student.prototype.hello = function () { alert('Hello, ' + this.name + '!'); } 以及Student的原型链： 现在，我们要基于Student扩展出PrimaryStudent，可以先定义出PrimaryStudent： function PrimaryStudent(props) { // 调用Student构造函数，绑定this变量: Student.call(this, props); this.grade = props.grade || 1; } 但是，调用了Student构造函数不等于继承了Student，PrimaryStudent创建的对象的原型是： new PrimaryStudent() ----> PrimaryStudent.prototype ----> Object.prototype ----> null 必须想办法把原型链修改为： new PrimaryStudent() ----> PrimaryStudent.prototype ----> Student.prototype ----> Object.prototype ----> null 我们必须借助一个中间对象来实现正确的原型链，这个中间对象的原型要指向Student.prototype。为了实现这一点，参考道爷（就是发明JSON的那个道格拉斯）的代码，中间对象可以用一个空函数F来实现： // PrimaryStudent构造函数: function PrimaryStudent(props) { Student.call(this, props); this.grade = props.grade || 1; } // 空函数F: function F() { } // 把F的原型指向Student.prototype: F.prototype = Student.prototype; // 把PrimaryStudent的原型指向一个新的F对象，F对象的原型正好指向Student.prototype: PrimaryStudent.prototype = new F(); // 把PrimaryStudent原型的构造函数修复为PrimaryStudent: PrimaryStudent.prototype.constructor = PrimaryStudent; // 继续在PrimaryStudent原型（就是new F()对象）上定义方法： PrimaryStudent.prototype.getGrade = function () { return this.grade; }; // 创建xiaoming: var xiaoming = new PrimaryStudent({ name: '小明', grade: 2 }); xiaoming.name; // '小明' xiaoming.grade; // 2 // 验证原型: xiaoming.__proto__ === PrimaryStudent.prototype; // true xiaoming.__proto__.__proto__ === Student.prototype; // true // 验证继承关系: xiaoming instanceof PrimaryStudent; // true xiaoming instanceof Student; // true 用一张图来表示新的原型链： 注意，函数F仅用于桥接，我们仅创建了一个new F()实例，而且，没有改变原有的Student定义的原型链。 "},"基础/class继承.html":{"url":"基础/class继承.html","title":"class继承","keywords":"","body":"class继承 JavaScript的对象模型是基于原型实现的，特点是简单，缺点是理解起来比传统的类－实例模型要困难，最大的缺点是继承的实现需要编写大量代码，并且需要正确实现原型链。 有没有更简单的写法？有！ 新的关键字class从ES6开始正式被引入到JavaScript中。class的目的就是让定义类更简单。 我们先回顾用函数实现Student的方法： function Student(name) { this.name = name; } Student.prototype.hello = function () { alert('Hello, ' + this.name + '!'); } 如果用新的class关键字来编写Student: class Student { constructor(name) { this.name = name; } hello() { alert('Hello, ' + this.name + '!'); } } 比较一下就可以发现，class的定义包含了构造函数constructor和定义在原型对象上的函数hello()（注意没有function关键字），这样就避免了Student.prototype.hello = function () {...}这样分散的代码。 最后，创建一个Student对象代码和前面章节完全一样： var xiaoming = new Student('小明'); xiaoming.hello(); class继承 用class定义对象的另一个巨大的好处是继承更方便了。想一想我们从Student派生一个PrimaryStudent需要编写的代码量。现在，原型继承的中间对象，原型对象的构造函数等等都不需要考虑了，直接通过extends来实现： class PrimaryStudent extends Student { constructor(name, grade) { super(name); // 记得用super调用父类的构造方法! this.grade = grade; } myGrade() { alert('I am at grade ' + this.grade); } } 注意PrimaryStudent的定义也是class关键字实现的，而extends则表示原型链对象来自Student。子类的构造函数可能会与父类不太相同，例如，PrimaryStudent需要name和grade两个参数，并且需要通过super(name)来调用父类的构造函数，否则父类的name属性无法正常初始化。 PrimaryStudent已经自动获得了父类Student的hello方法，我们又在子类中定义了新的myGrade方法。 ES6引入的class和原有的JavaScript原型继承有什么区别呢？实际上它们没有任何区别，class的作用就是让JavaScript引擎去实现原来需要我们自己编写的原型链代码。简而言之，用class的好处就是极大地简化了原型链代码。 你一定会问，class这么好用，能不能现在就用上？ 现在用还早了点，因为不是所有的主流浏览器都支持ES6的class。如果一定要现在就用上，就需要一个工具把class代码转换为传统的prototype代码，可以试试Babel这个工具。 "},"浏览器/浏览器.html":{"url":"浏览器/浏览器.html","title":"浏览器","keywords":"","body":"浏览器 由于JavaScript的出现就是为了能在浏览器中运行，所以，浏览器自然是JavaScript开发者必须要关注的。 目前主流的浏览器分这么几种： IE 6~11：国内用得最多的IE浏览器，历来对W3C标准支持差。从IE10开始支持ES6标准； Chrome：Google出品的基于Webkit内核浏览器，内置了非常强悍的JavaScript引擎——V8。由于Chrome一经安装就时刻保持自升级，所以不用管它的版本，最新版早就支持ES6了； Safari：Apple的Mac系统自带的基于Webkit内核的浏览器，从OS X 10.7 Lion自带的6.1版本开始支持ES6，目前最新的OS X 10.11 El Capitan自带的Safari版本是9.x，早已支持ES6； Firefox：Mozilla自己研制的Gecko内核和JavaScript引擎OdinMonkey。早期的Firefox按版本发布，后来终于聪明地学习Chrome的做法进行自升级，时刻保持最新； 移动设备上目前iOS和Android两大阵营分别主要使用Apple的Safari和Google的Chrome，由于两者都是Webkit核心，结果HTML5首先在手机上全面普及（桌面绝对是Microsoft拖了后腿），对JavaScript的标准支持也很好，最新版本均支持ES6。 其他浏览器如Opera等由于市场份额太小就被自动忽略了。 另外还要注意识别各种国产浏览器，如某某安全浏览器，某某旋风浏览器，它们只是做了一个壳，其核心调用的是IE，也有号称同时支持IE和Webkit的“双核”浏览器。 不同的浏览器对JavaScript支持的差异主要是，有些API的接口不一样，比如AJAX，File接口。对于ES6标准，不同的浏览器对各个特性支持也不一样。 在编写JavaScript的时候，就要充分考虑到浏览器的差异，尽量让同一份JavaScript代码能运行在不同的浏览器中。 "},"浏览器/浏览器对象.html":{"url":"浏览器/浏览器对象.html","title":"浏览器对象","keywords":"","body":"浏览器对象 JavaScript可以获取浏览器提供的很多对象，并进行操作。 window window对象不但充当全局作用域，而且表示浏览器窗口。 window对象有innerWidth和innerHeight属性，可以获取浏览器窗口的内部宽度和高度。内部宽高是指除去菜单栏、工具栏、边框等占位元素后，用于显示网页的净宽高。 兼容性：IE 对应的，还有一个outerWidth和outerHeight属性，可以获取浏览器窗口的整个宽高。 navigator navigator对象表示浏览器的信息，最常用的属性包括： navigator.appName：浏览器名称； navigator.appVersion：浏览器版本； navigator.language：浏览器设置的语言； navigator.platform：操作系统类型； navigator.userAgent：浏览器设定的User-Agent字符串。 请注意，navigator的信息可以很容易地被用户修改，所以JavaScript读取的值不一定是正确的。很多初学者为了针对不同浏览器编写不同的代码，喜欢用if判断浏览器版本，例如： var width; if (getIEVersion(navigator.userAgent) 但这样既可能判断不准确，也很难维护代码。正确的方法是充分利用JavaScript对不存在属性返回undefined的特性，直接用短路运算符||计算： var width = window.innerWidth || document.body.clientWidth; screen screen对象表示屏幕的信息，常用的属性有： screen.width：屏幕宽度，以像素为单位； screen.height：屏幕高度，以像素为单位； screen.colorDepth：返回颜色位数，如8、16、24。 location location对象表示当前页面的URL信息。例如，一个完整的URL： http://www.example.com:8080/path/index.html?a=1&b=2#TOP 可以用location.href获取。要获得URL各个部分的值，可以这么写： location.protocol; // 'http' location.host; // 'www.example.com' location.port; // '8080' location.pathname; // '/path/index.html' location.search; // '?a=1&b=2' location.hash; // 'TOP' document document对象表示当前页面。由于HTML在浏览器中以DOM形式表示为树形结构，document对象就是整个DOM树的根节点。 document的title属性是从HTML文档中的xxx读取的，但是可以动态改变： document.title = '努力学习JavaScript!'; 要查找DOM树的某个节点，需要从document对象开始查找。最常用的查找是根据ID和Tag Name。 我们先准备HTML数据： 摩卡 热摩卡咖啡 酸奶 北京老酸奶 果汁 鲜榨苹果汁 用document对象提供的getElementById()和getElementsByTagName()可以按ID获得一个DOM节点和按Tag名称获得一组DOM节点： var menu = document.getElementById('drink-menu'); var drinks = document.getElementsByTagName('dt'); var i, s; s = '提供的饮料有:'; for (i=0; i document对象还有一个cookie属性，可以获取当前页面的Cookie。 Cookie是由服务器发送的key-value标示符。因为HTTP协议是无状态的，但是服务器要区分到底是哪个用户发过来的请求，就可以用Cookie来区分。当一个用户成功登录后，服务器发送一个Cookie给浏览器，例如user=ABC123XYZ(加密的字符串)...，此后，浏览器访问该网站时，会在请求头附上这个Cookie，服务器根据Cookie即可区分出用户。 Cookie还可以存储网站的一些设置，例如，页面显示的语言等等。 history history对象保存了浏览器的历史记录，JavaScript可以调用history对象的back()或forward ()，相当于用户点击了浏览器的“后退”或“前进”按钮。 这个对象属于历史遗留对象，对于现代Web页面来说，由于大量使用AJAX和页面交互，简单粗暴地调用history.back()可能会让用户感到非常愤怒。 新手开始设计Web页面时喜欢在登录页登录成功时调用history.back()，试图回到登录前的页面。这是一种错误的方法。 任何情况，你都不应该使用history这个对象了。 "},"浏览器/操作DOM.html":{"url":"浏览器/操作DOM.html","title":"操作DOM","keywords":"","body":"操作DOM 由于HTML文档被浏览器解析后就是一棵DOM树，要改变HTML的结构，就需要通过JavaScript来操作DOM。 始终记住DOM是一个树形结构。操作一个DOM节点实际上就是这么几个操作： 更新：更新该DOM节点的内容，相当于更新了该DOM节点表示的HTML的内容； 遍历：遍历该DOM节点下的子节点，以便进行进一步操作； 添加：在该DOM节点下新增一个子节点，相当于动态增加了一个HTML节点； 删除：将该节点从HTML中删除，相当于删掉了该DOM节点的内容以及它包含的所有子节点。 在操作一个DOM节点前，我们需要通过各种方式先拿到这个DOM节点。最常用的方法是document.getElementById()和document.getElementsByTagName()，以及CSS选择器document.getElementsByClassName()。 由于ID在HTML文档中是唯一的，所以document.getElementById()可以直接定位唯一的一个DOM节点。document.getElementsByTagName()和document.getElementsByClassName()总是返回一组DOM节点。要精确地选择DOM，可以先定位父节点，再从父节点开始选择，以缩小范围。 // 返回ID为'test'的节点： var test = document.getElementById('test'); // 先定位ID为'test-table'的节点，再返回其内部所有tr节点： var trs = document.getElementById('test-table').getElementsByTagName('tr'); // 先定位ID为'test-div'的节点，再返回其内部所有class包含red的节点： var reds = document.getElementById('test-div').getElementsByClassName('red'); // 获取节点test下的所有直属子节点: var cs = test.children; // 获取节点test下第一个、最后一个子节点： var first = test.firstElementChild; var last = test.lastElementChild; 第二种方法是使用querySelector()和querySelectorAll()，需要了解selector语法，然后使用条件来获取节点，更加方便： // 通过querySelector获取ID为q1的节点： var q1 = document.querySelector('#q1'); // 通过querySelectorAll获取q1节点内的符合条件的所有节点： var ps = q1.querySelectorAll('div.highlighted > p'); 注意：低版本的IEquerySelector和querySelectorAll。IE8仅有限支持。 严格地讲，我们这里的DOM节点是指Element，但是DOM节点实际上是Node，在HTML中，Node包括Element、Comment、CDATA_SECTION等很多种，以及根节点Document类型，但是，绝大多数时候我们只关心Element，也就是实际控制页面结构的Node，其他类型的Node忽略即可。根节点Document已经自动绑定为全局变量document。 "},"浏览器/更新DOM.html":{"url":"浏览器/更新DOM.html","title":"更新DOM","keywords":"","body":"更新DOM 拿到一个DOM节点后，我们可以对它进行更新。 可以直接修改节点的文本，方法有两种： 一种是修改innerHTML属性，这个方式非常强大，不但可以修改一个DOM节点的文本内容，还可以直接通过HTML片段修改DOM节点内部的子树： // 获取... var p = document.getElementById('p-id'); // 设置文本为abc: p.innerHTML = 'ABC'; // ABC // 设置HTML: p.innerHTML = 'ABC RED XYZ'; // ...的内部结构已修改 用innerHTML时要注意，是否需要写入HTML。如果写入的字符串是通过网络拿到了，要注意对字符编码来避免XSS攻击。 第二种是修改innerText或textContent属性，这样可以自动对字符串进行HTML编码，保证无法设置任何HTML标签： // 获取... var p = document.getElementById('p-id'); // 设置文本: p.innerText = 'alert(\"Hi\")'; // HTML被自动编码，无法设置一个节点: // &lt;script&gt;alert(\"Hi\")&lt;/script&gt; 两者的区别在于读取属性时，innerText不返回隐藏元素的文本，而textContent返回所有文本。另外注意IEtextContent。 修改CSS也是经常需要的操作。DOM节点的style属性对应所有的CSS，可以直接获取或设置。因为CSS允许font-size这样的名称，但它并非JavaScript有效的属性名，所以需要在JavaScript中改写为驼峰式命名fontSize： // 获取... var p = document.getElementById('p-id'); // 设置CSS: p.style.color = '#ff0000'; p.style.fontSize = '20px'; p.style.paddingTop = '2em'; "},"浏览器/插入DOM.html":{"url":"浏览器/插入DOM.html","title":"插入DOM","keywords":"","body":"插入DOM 当我们获得了某个DOM节点，想在这个DOM节点内插入新的DOM，应该如何做？ 如果这个DOM节点是空的，例如，，那么，直接使用innerHTML = 'child'就可以修改DOM节点的内容，相当于“插入”了新的DOM节点。 如果这个DOM节点不是空的，那就不能这么做，因为innerHTML会直接替换掉原来的所有子节点。 有两个办法可以插入新的节点。一个是使用appendChild，把一个子节点添加到父节点的最后一个子节点。例如： JavaScript Java Python Scheme 把JavaScript添加到的最后一项： var js = document.getElementById('js'); var list = document.getElementById('list'); list.appendChild(js); 现在，HTML结构变成了这样： Java Python Scheme JavaScript 因为我们插入的js节点已经存在于当前的文档树，因此这个节点首先会从原先的位置删除，再插入到新的位置。 更多的时候我们会从零创建一个新的节点，然后插入到指定位置： var list = document.getElementById('list'); var haskell = document.createElement('p'); haskell.id = 'haskell'; haskell.innerText = 'Haskell'; list.appendChild(haskell); 这样我们就动态添加了一个新的节点： Java Python Scheme Haskell insertBefore 如果我们要把子节点插入到指定的位置怎么办？可以使用parentElement.insertBefore(newElement, referenceElement);，子节点会插入到referenceElement之前。 还是以上面的HTML为例，假定我们要把Haskell插入到Python之前： Java Python Scheme 可以这么写： var list = document.getElementById('list'); var ref = document.getElementById('python'); var haskell = document.createElement('p'); haskell.id = 'haskell'; haskell.innerText = 'Haskell'; list.insertBefore(haskell, ref); 新的HTML结构如下： Java Haskell Python Scheme "},"浏览器/删除DOM.html":{"url":"浏览器/删除DOM.html","title":"删除DOM","keywords":"","body":"删除DOM 删除一个DOM节点就比插入要容易得多。 要删除一个节点，首先要获得该节点本身以及它的父节点，然后，调用父节点的removeChild把自己删掉： // 拿到待删除节点: var self = document.getElementById('to-be-removed'); // 拿到父节点: var parent = self.parentElement; // 删除: var removed = parent.removeChild(self); removed === self; // true 注意到删除后的节点虽然不在文档树中了，但其实它还在内存中，可以随时再次被添加到别的位置。 当你遍历一个父节点的子节点并进行删除操作时，要注意，children属性是一个只读属性，并且它在子节点变化时会实时更新。 例如，对于如下HTML结构： First Second 当我们用如下代码删除子节点时： var parent = document.getElementById('parent'); parent.removeChild(parent.children[0]); parent.removeChild(parent.children[1]); // 浏览器报错：parent.children[1]不是一个有效的节点。原因就在于，当First节点被删除后，parent.children的节点数量已经从2变为了1，索引[1]已经不存在了。 因此，删除多个节点时，要注意children属性时刻都在变化。 "},"浏览器/操作表单.html":{"url":"浏览器/操作表单.html","title":"操作表单","keywords":"","body":"操作表单 用JavaScript操作表单和操作DOM是类似的，因为表单本身也是DOM树。 不过表单的输入框、下拉框等可以接收用户输入，所以用JavaScript来操作表单，可以获得用户输入的内容，或者对一个输入框设置新的内容。 HTML表单的输入控件主要有以下几种： 文本框，对应的，用于输入文本； 口令框，对应的，用于输入口令； 单选框，对应的，用于选择一项； 复选框，对应的，用于选择多项； 下拉框，对应的，用于选择一项； 隐藏文本，对应的，用户不可见，但表单提交时会把隐藏文本发送到服务器。 获取值 如果我们获得了一个节点的引用，就可以直接调用value获得对应的用户输入值： // var input = document.getElementById('email'); input.value; // '用户输入的值' 这种方式可以应用于text、password、hidden以及select。但是，对于单选框和复选框，value属性返回的永远是HTML预设的值，而我们需要获得的实际是用户是否“勾上了”选项，所以应该用checked判断： // Monday // Tuesday var mon = document.getElementById('monday'); var tue = document.getElementById('tuesday'); mon.value; // '1' tue.value; // '2' mon.checked; // true或者false tue.checked; // true或者false 设置值 设置值和获取值类似，对于text、password、hidden以及select，直接设置value就可以： // var input = document.getElementById('email'); input.value = 'test@example.com'; // 文本框的内容已更新 HTML5控件 HTML5新增了大量标准控件，常用的包括date、datetime、datetime-local、color等，它们都使用标签： 不支持HTML5的浏览器无法识别新的控件，会把它们当做type=\"text\"来显示。支持HTML5的浏览器将获得格式化的字符串。例如，type=\"date\"类型的input的value将保证是一个有效的YYYY-MM-DD格式的日期，或者空字符串。 "},"浏览器/操作文件.html":{"url":"浏览器/操作文件.html","title":"操作文件","keywords":"","body":"操作文件 在HTML表单中，可以上传文件的唯一控件就是。 注意：当一个表单包含时，表单的enctype必须指定为multipart/form-data，method必须指定为post，浏览器才能正确编码并以multipart/form-data格式发送表单的数据。 出于安全考虑，浏览器只允许用户点击来选择本地文件，用JavaScript对的value赋值是没有任何效果的。当用户选择了上传某个文件后，JavaScript也无法获得该文件的。 通常，上传的文件都由后台服务器处理，JavaScript可以在提交表单时对文件扩展名做检查，以便防止用户上传无效格式的文件： var f = document.getElementById('test-file-upload'); var filename = f.value; // 'C:\\fakepath\\test.png' if (!filename || !(filename.endsWith('.jpg') || filename.endsWith('.png') || filename.endsWith('.gif'))) { alert('Can only upload image file.'); return false; } 回调 JavaScript的一个重要的特性就是单线程执行模式。在JavaScript中，浏览器的JavaScript执行引擎在执行JavaScript代码时，总是以单线程模式执行，也就是说，任何时候，JavaScript代码都不可能同时有多于1个线程在执行。 你可能会问，单线程模式执行的JavaScript，如何处理多任务？ 在JavaScript中，执行多任务实际上都是异步调用. "},"浏览器/AJAX.html":{"url":"浏览器/AJAX.html","title":"AJAX","keywords":"","body":"AJAX AJAX不是JavaScript的规范，它只是一个哥们“发明”的缩写：Asynchronous JavaScript and XML，意思就是用JavaScript执行异步网络请求。 如果仔细观察一个Form的提交，你就会发现，一旦用户点击“Submit”按钮，表单开始提交，浏览器就会刷新页面，然后在新页面里告诉你操作是成功了还是失败了。如果不幸由于网络太慢或者其他原因，就会得到一个404页面。 这就是Web的运作原理：一次HTTP请求对应一个页面。 如果要让用户留在当前页面中，同时发出新的HTTP请求，就必须用JavaScript发送这个新请求，接收到数据后，再用JavaScript更新页面，这样一来，用户就感觉自己仍然停留在当前页面，但是数据却可以不断地更新。 最早大规模使用AJAX的就是Gmail，Gmail的页面在首次加载后，剩下的所有数据都依赖于AJAX来更新。 用JavaScript写一个完整的AJAX代码并不复杂，但是需要注意：AJAX请求是异步执行的，也就是说，要通过回调函数获得响应。 在现代浏览器上写AJAX主要依靠XMLHttpRequest对象： function success(text) { var textarea = document.getElementById('test-response-text'); textarea.value = text; } function fail(code) { var textarea = document.getElementById('test-response-text'); textarea.value = 'Error code: ' + code; } var request = new XMLHttpRequest(); // 新建XMLHttpRequest对象 request.onreadystatechange = function () { // 状态发生变化时，函数被回调 if (request.readyState === 4) { // 成功完成 // 判断响应结果: if (request.status === 200) { // 成功，通过responseText拿到响应的文本: return success(request.responseText); } else { // 失败，根据响应码判断失败原因: return fail(request.status); } } else { // HTTP请求还在继续... } } // 发送请求: request.open('GET', '/api/categories'); request.send(); alert('请求已发送，请等待响应...'); 对于低版本的IE，需要换一个ActiveXObject对象： var request = new ActiveXObject('Microsoft.XMLHTTP'); // 新建Microsoft.XMLHTTP对象 如果你想把标准写法和IE写法混在一起，可以这么写： var request; if (window.XMLHttpRequest) { request = new XMLHttpRequest(); } else { request = new ActiveXObject('Microsoft.XMLHTTP'); } 通过检测window对象是否有XMLHttpRequest属性来确定浏览器是否支持标准的XMLHttpRequest。注意，不要根据浏览器的navigator.userAgent来检测浏览器是否支持某个JavaScript特性，一是因为这个字符串本身可以伪造，二是通过IE版本判断JavaScript特性将非常复杂。 当创建了XMLHttpRequest对象后，要先设置onreadystatechange的回调函数。在回调函数中，通常我们只需通过readyState === 4判断请求是否完成，如果已完成，再根据status === 200判断是否是一个成功的响应。 XMLHttpRequest对象的open()方法有3个参数，第一个参数指定是GET还是POST，第二个参数指定URL地址，第三个参数指定是否使用异步，默认是true，所以不用写。 注意，千万不要把第三个参数指定为false，否则浏览器将停止响应，直到AJAX请求完成。如果这个请求耗时10秒，那么10秒内你会发现浏览器处于“假死”状态。 最后调用send()方法才真正发送请求。GET请求不需要参数，POST请求需要把body部分以字符串或者FormData对象传进去。 安全限制 上面代码的URL使用的是相对路径。如果你把它改为'http://www.sina.com.cn/'，再运行，肯定报错。在Chrome的控制台里，还可以看到错误信息。 这是因为浏览器的同源策略导致的。默认情况下，JavaScript在发送AJAX请求时，URL的域名必须和当前页面完全一致。 完全一致的意思是，域名要相同（www.example.com和example.com不同），协议要相同（http和https不同），端口号要相同（默认是:80端口，它和:8080就不同）。有的浏览器口子松一点，允许端口不同，大多数浏览器都会严格遵守这个限制。 那是不是用JavaScript无法请求外域（就是其他网站）的URL了呢？方法还是有的，大概有这么几种： 一是通过Flash插件发送HTTP请求，这种方式可以绕过浏览器的安全限制，但必须安装Flash，并且跟Flash交互。不过Flash用起来麻烦，而且现在用得也越来越少了。 二是通过在同源域名下架设一个代理服务器来转发，JavaScript负责把请求发送到代理服务器： '/proxy?url=http://www.sina.com.cn' 代理服务器再把结果返回，这样就遵守了浏览器的同源策略。这种方式麻烦之处在于需要服务器端额外做开发。 第三种方式称为JSONP，它有个限制，只能用GET请求，并且要求返回JavaScript。这种方式跨域实际上是利用了浏览器允许跨域引用JavaScript资源： ... ... JSONP通常以函数调用的形式返回，例如，返回JavaScript内容如下： foo('data'); 这样一来，我们如果在页面中先准备好foo()函数，然后给页面动态加一个节点，相当于动态读取外域的JavaScript资源，最后就等着接收回调了。 以163的股票查询URL为例，对于URL：http://api.money.126.net/data/feed/0000001,1399001?callback=refreshPrice，你将得到如下返回： refreshPrice({\"0000001\":{\"code\": \"0000001\", ... }); 因此我们需要首先在页面中准备好回调函数： function refreshPrice(data) { var p = document.getElementById('test-jsonp'); p.innerHTML = '当前价格：' + data['0000001'].name +': ' + data['0000001'].price + '；' + data['1399001'].name + ': ' + data['1399001'].price; } 最后用getPrice()函数触发： function getPrice() { var js = document.createElement('script'), head = document.getElementsByTagName('head')[0]; js.src = 'http://api.money.126.net/data/feed/0000001,1399001?callback=refreshPrice'; head.appendChild(js); } 就完成了跨域加载数据。 CORS 如果浏览器支持HTML5，那么就可以一劳永逸地使用新的跨域策略：CORS了。 CORS全称Cross-Origin Resource Sharing，是HTML5规范定义的如何跨域访问资源。 了解CORS前，我们先搞明白概念： Origin表示本域，也就是浏览器当前页面的域。当JavaScript向外域（如sina.com）发起请求后，浏览器收到响应后，首先检查Access-Control-Allow-Origin是否包含本域，如果是，则此次跨域请求成功，如果不是，则请求失败，JavaScript将无法获取到响应的任何数据。 用一个图来表示就是： 假设本域是my.com，外域是sina.com，只要响应头Access-Control-Allow-Origin为http://my.com，或者是*，本次请求就可以成功。 可见，跨域能否成功，取决于对方服务器是否愿意给你设置一个正确的Access-Control-Allow-Origin，决定权始终在对方手中。 上面这种跨域请求，称之为“简单请求”。简单请求包括GET、HEAD和POST（POST的Content-Type类型 仅限application/x-www-form-urlencoded、multipart/form-data和text/plain），并且不能出现任何自定义头（例如，X-Custom: 12345），通常能满足90%的需求。 无论你是否需要用JavaScript通过CORS跨域请求资源，你都要了解CORS的原理。最新的浏览器全面支持HTML5。在引用外域资源时，除了JavaScript和CSS外，都要验证CORS。例如，当你引用了某个第三方CDN上的字体文件时： /* CSS */ @font-face { font-family: 'FontAwesome'; src: url('http://cdn.com/fonts/fontawesome.ttf') format('truetype'); } 如果该CDN服务商未正确设置Access-Control-Allow-Origin，那么浏览器无法加载字体资源。 对于PUT、DELETE以及其他类型如application/json的POST请求，在发送AJAX请求之前，浏览器会先发送一个OPTIONS请求（称为preflighted请求）到这个URL上，询问目标服务器是否接受： OPTIONS /path/to/resource HTTP/1.1 Host: bar.com Origin: http://my.com Access-Control-Request-Method: POST 服务器必须响应并明确指出允许的Method： HTTP/1.1 200 OK Access-Control-Allow-Origin: http://my.com Access-Control-Allow-Methods: POST, GET, PUT, OPTIONS Access-Control-Max-Age: 86400 浏览器确认服务器响应的Access-Control-Allow-Methods头确实包含将要发送的AJAX请求的Method，才会继续发送AJAX，否则，抛出一个错误。 由于以POST、PUT方式传送JSON格式的数据在REST中很常见，所以要跨域正确处理POST和PUT请求，服务器端必须正确响应OPTIONS请求。 "},"浏览器/Promise.html":{"url":"浏览器/Promise.html","title":"Promise","keywords":"","body":"Promise 在JavaScript的世界中，所有代码都是单线程执行的。 由于这个“缺陷”，导致JavaScript的所有网络操作，浏览器事件，都必须是异步执行。异步执行可以用回调函数实现： function callback() { console.log('Done'); } console.log('before setTimeout()'); setTimeout(callback, 1000); // 1秒钟后调用callback函数 console.log('after setTimeout()'); 观察上述代码执行，在Chrome的控制台输出可以看到： before setTimeout() after setTimeout() (等待1秒后) Done 可见，异步操作会在将来的某个时间点触发一个函数调用。AJAX就是典型的异步操作. 我们先看一个最简单的Promise例子：生成一个0-2之间的随机数，如果小于1，则等待一段时间后返回成功，否则返回失败： function test(resolve, reject) { var timeOut = Math.random() * 2; log('set timeout to: ' + timeOut + ' seconds.'); setTimeout(function () { if (timeOut 这个test()函数有两个参数，这两个参数都是函数，如果执行成功，我们将调用resolve('200 OK')，如果执行失败，我们将调用reject('timeout in ' + timeOut + ' seconds.')。可以看出，test()函数只关心自身的逻辑，并不关心具体的resolve和reject将如何处理结果。 有了执行函数，我们就可以用一个Promise对象来执行它，并在将来某个时刻获得成功或失败的结果： var p1 = new Promise(test); var p2 = p1.then(function (result) { console.log('成功：' + result); }); var p3 = p2.catch(function (reason) { console.log('失败：' + reason); }); 变量p1是一个Promise对象，它负责执行test函数。由于test函数在内部是异步执行的，当test函数执行成功时，我们告诉Promise对象： // 如果成功，执行这个函数： p1.then(function (result) { console.log('成功：' + result); }); 当test函数执行失败时，我们告诉Promise对象： p2.catch(function (reason) { console.log('失败：' + reason); }); Promise对象可以串联起来，所以上述代码可以简化为： new Promise(test).then(function (result) { console.log('成功：' + result); }).catch(function (reason) { console.log('失败：' + reason); }); 可见Promise最大的好处是在异步执行的流程中，把执行代码和处理结果的代码清晰地分离了： Promise还可以做更多的事情，比如，有若干个异步任务，需要先做任务1，如果成功后再做任务2，任何任务失败则不再继续并执行错误处理函数。 要串行执行这样的异步任务，不用Promise需要写一层一层的嵌套代码。有了Promise，我们只需要简单地写： job1.then(job2).then(job3).catch(handleError); 其中，job1、job2和job3都是Promise对象。 例如： // 0.5秒后返回input*input的计算结果: function multiply(input) { return new Promise(function (resolve, reject) { log('calculating ' + input + ' x ' + input + '...'); setTimeout(resolve, 500, input * input); }); } // 0.5秒后返回input+input的计算结果: function add(input) { return new Promise(function (resolve, reject) { log('calculating ' + input + ' + ' + input + '...'); setTimeout(resolve, 500, input + input); }); } var p = new Promise(function (resolve, reject) { log('start new Promise...'); resolve(123); }); p.then(multiply) .then(add) .then(multiply) .then(add) .then(function (result) { log('Got value: ' + result); }); Log: start new Promise... calculating 123 x 123... calculating 15129 + 15129... calculating 30258 x 30258... calculating 915546564 + 915546564... Got value: 1831093128 现在，我们把AJAX异步执行函数转换为Promise对象，看看用Promise如何简化异步处理： // ajax函数将返回Promise对象: function ajax(method, url, data) { var request = new XMLHttpRequest(); return new Promise(function (resolve, reject) { request.onreadystatechange = function () { if (request.readyState === 4) { if (request.status === 200) { resolve(request.responseText); } else { reject(request.status); } } }; request.open(method, url); request.send(data); }); } var p = ajax('GET', '/api/categories'); p.then(function (text) { // 如果AJAX成功，获得响应内容 }).catch(function (status) { // 如果AJAX失败，获得响应代码 }); 除了串行执行若干异步任务外，Promise还可以并行执行异步任务。 试想一个页面聊天系统，我们需要从两个不同的URL分别获得用户的个人信息和好友列表，这两个任务是可以并行执行的，用Promise.all()实现如下： var p1 = new Promise(function (resolve, reject) { setTimeout(resolve, 500, 'P1'); }); var p2 = new Promise(function (resolve, reject) { setTimeout(resolve, 600, 'P2'); }); // 同时执行p1和p2，并在它们都完成后执行then: Promise.all([p1, p2]).then(function (results) { console.log(results); // 获得一个Array: ['P1', 'P2'] }); 有些时候，多个异步任务是为了容错。比如，同时向两个URL读取用户的个人信息，只需要获得先返回的结果即可。这种情况下，用Promise.race()实现： var p1 = new Promise(function (resolve, reject) { setTimeout(resolve, 500, 'P1'); }); var p2 = new Promise(function (resolve, reject) { setTimeout(resolve, 600, 'P2'); }); Promise.race([p1, p2]).then(function (result) { console.log(result); // 'P1' }); 由于p1执行较快，Promise的then()将获得结果'P1'。p2仍在继续执行，但执行结果将被丢弃。 如果我们组合使用Promise，就可以把很多异步任务以并行和串行的方式组合起来执行。 "},"浏览器/Canvas.html":{"url":"浏览器/Canvas.html","title":"Canvas","keywords":"","body":"Canvas Canvas是HTML5新增的组件，它就像一块幕布，可以用JavaScript在上面绘制各种图表、动画等。 没有Canvas的年代，绘图只能借助Flash插件实现，页面不得不用JavaScript和Flash进行交互。有了Canvas，我们就再也不需要Flash了，直接使用JavaScript完成绘制。 一个Canvas定义了一个指定尺寸的矩形框，在这个范围内我们可以随意绘制： 由于浏览器对HTML5标准支持不一致，所以，通常在内部添加一些说明性HTML代码，如果浏览器支持Canvas，它将忽略内部的HTML，如果浏览器不支持Canvas，它将显示内部的HTML： Current Price: 25.51 在使用Canvas前，用canvas.getContext来测试浏览器是否支持Canvas： var canvas = document.getElementById('test-canvas'); if (canvas.getContext) { console.log('你的浏览器支持Canvas!'); } else { console.log('你的浏览器不支持Canvas!'); } getContext('2d')方法让我们拿到一个CanvasRenderingContext2D对象，所有的绘图操作都需要通过这个对象完成。 var ctx = canvas.getContext('2d'); 如果需要绘制3D怎么办？HTML5还有一个WebGL规范，允许在Canvas中绘制3D图形： gl = canvas.getContext(\"webgl\"); 具体绘制详情w3c. "},"Jquery/jquery.html":{"url":"Jquery/jquery.html","title":"Jquery","keywords":"","body":"Jquery 你可能听说过jQuery，它名字起得很土，但却是JavaScript世界中使用最广泛的一个库。 江湖传言，全世界大约有80~90%的网站直接或间接地使用了jQuery。鉴于它如此流行，又如此好用，所以每一个入门JavaScript的前端工程师都应该了解和学习它。 jQuery这么流行，肯定是因为它解决了一些很重要的问题。实际上，jQuery能帮我们干这些事情： 消除浏览器差异：你不需要自己写冗长的代码来针对不同的浏览器来绑定事件，编写AJAX等代码； 简洁的操作DOM的方法：写$('#test')肯定比document.getElementById('test')来得简洁； 轻松实现动画、修改CSS等各种操作。 jQuery的理念“Write Less, Do More“，让你写更少的代码，完成更多的工作！ 使用jQuery 使用jQuery只需要在页面的引入jQuery文件即可： ... ... 查看Jquery版本： console.log('jQuery版本：' + $.fn.jquery); $符号 $是著名的jQuery符号。实际上，jQuery把所有功能全部封装在一个全局变量jQuery中，而$也是一个合法的变量名，它是变量jQuery的别名： window.jQuery; // jQuery(selector, context) window.$; // jQuery(selector, context) $ === jQuery; // true typeof($); // 'function' $本质上就是一个函数，但是函数也是对象，于是$除了可以直接调用外，也可以有很多其他属性。 注意，你看到的$函数名可能不是jQuery(selector, context)，因为很多JavaScript压缩工具可以对函数名和参数改名，所以压缩过的jQuery源码$函数可能变成a(b, c)。 绝大多数时候，我们都直接用$（因为写起来更简单嘛）。但是，如果$这个变量不幸地被占用了，而且还不能改，那我们就只能让jQuery把$变量交出来，然后就只能使用jQuery这个变量. "},"Jquery/选择器.html":{"url":"Jquery/选择器.html","title":"选择器","keywords":"","body":"选择器 选择器是jQuery的核心。一个选择器写出来类似$('#dom-id')。 为什么jQuery要发明选择器？回顾一下DOM操作中我们经常使用的代码： // 按ID查找： var a = document.getElementById('dom-id'); // 按tag查找： var divs = document.getElementsByTagName('div'); // 查找： var ps = document.getElementsByTagName('p'); // 过滤出class=\"red\": // TODO: // 查找里面的所有： var table = ... for (var i=0; i } jQuery的选择器就是帮助我们快速定位到一个或多个DOM节点。 按ID查找 如果某个DOM节点有id属性，利用jQuery查找如下： // 查找: var div = $('#abc'); 注意，#abc以#开头。返回的对象是jQuery对象。 什么是jQuery对象？jQuery对象类似数组，它的每个元素都是一个引用了DOM节点的对象。 以上面的查找为例，如果id为abc的存在，返回的jQuery对象如下： [...] 如果id为abc的不存在，返回的jQuery对象如下： [] 总之jQuery的选择器不会返回undefined或者null，这样的好处是你不必在下一行判断if (div === undefined)。 jQuery对象和DOM对象之间可以互相转化： var div = $('#abc'); // jQuery对象 var divDom = div.get(0); // 假设存在div，获取第1个DOM元素 var another = $(divDom); // 重新把DOM包装为jQuery对象 通常情况下你不需要获取DOM对象，直接使用jQuery对象更加方便。如果你拿到了一个DOM对象，那可以简单地调用$(aDomObject)把它变成jQuery对象，这样就可以方便地使用jQuery的API了。 按tag查找 按tag查找只需要写上tag名称就可以了： var ps = $('p'); // 返回所有节点 ps.length; // 数一数页面有多少个节点 按class查找 按class查找注意在class名称前加一个.： var a = $('.red'); // 所有节点包含`class=\"red\"`都将返回 // 例如: // ... // ... 通常很多节点有多个class，我们可以查找同时包含red和green的节点： var a = $('.red.green'); // 注意没有空格！ // 符合条件的节点： // ... // ... 按属性查找 一个DOM节点除了id和class外还可以有很多属性，很多时候按属性查找会非常方便，比如在一个表单中按属性来查找： var email = $('[name=email]'); // 找出 var passwordInput = $('[type=password]'); // 找出 var a = $('[items=\"A B\"]'); // 找出 当属性的值包含空格等特殊字符时，需要用双引号括起来。 按属性查找还可以使用前缀查找或者后缀查找： var icons = $('[name^=icon]'); // 找出所有name属性值以icon开头的DOM // 例如: name=\"icon-1\", name=\"icon-2\" var names = $('[name$=with]'); // 找出所有name属性值以with结尾的DOM // 例如: name=\"startswith\", name=\"endswith\" // $(\"[href!='#']\") 选取所有带有 href 值不等于 \"#\" 的元素。 组合查找 组合查找就是把上述简单选择器组合起来使用。如果我们查找$('[name=email]')，很可能把表单外的也找出来，但我们只希望查找，就可以这么写： var emailInput = $('input[name=email]'); // 不会找出 同样的，根据tag和class来组合查找也很常见： var tr = $('tr.red'); // 找出... 多项选择器 多项选择器就是把多个选择器用,组合起来一块选： $('p,div'); // 把和都选出来 $('p.red,p.green'); // 把和都选出来 要注意的是，选出来的元素是按照它们在HTML中出现的顺序排列的，而且不会有重复元素。例如，不会被上面的$('p.red,p.green')选择两次。 其他关于 jquery 选择器详情官网 "},"Jquery/层级选择器.html":{"url":"Jquery/层级选择器.html","title":"层级选择器","keywords":"","body":"层级选择器 除了基本的选择器外，JQuery的层级选择器更加灵活，也更强大。 因为DOM的结构就是层级结构，所以我们经常要根据层级关系进行选择。 ancestor descendant --> 在ancestor元素下匹配所有的后代元素descendant $(\"form input\"); // 选择form所有input后代 parent > child --> 在指定父元素下匹配所有的子元素 $(\"form>input\"); // 选择form的下一级所有的input prev + next --> 匹配所有紧挨着在 prev 元素后的 next 元素 $(\"label+input\"); // 匹配所有label的兄弟节点input "},"Jquery/查找和过滤.html":{"url":"Jquery/查找和过滤.html","title":"查找和过滤","keywords":"","body":"查找和过滤 通常情况下选择器可以直接定位到我们想要的元素，但是，当我们拿到一个jQuery对象后，还可以以这个对象为基准，进行查找和过滤。 最常见的查找是在某个节点的所有子节点中查找，使用find()方法，它本身又接收一个任意的选择器。例如如下的HTML结构： JavaScript Python Swift Scheme Haskell 用find()查找： var ul = $('ul.lang'); // 获得 var dy = ul.find('.dy'); // 获得JavaScript, Python, Scheme var swf = ul.find('#swift'); // 获得Swift var hsk = ul.find('[name=haskell]'); // 获得Haskell 如果要从当前节点开始向上查找，使用parent()方法： var swf = $('#swift'); // 获得Swift var parent = swf.parent(); // 获得Swift的上层节点 var a = swf.parent('.red'); // 获得Swift的上层节点，同时传入过滤条件。如果ul不符合条件，返回空jQuery对象 对于位于同一层级的节点，可以通过next()和prev()方法，例如： 当我们已经拿到Swift节点后： var swift = $('#swift'); swift.next(); // Scheme swift.next('[name=haskell]'); // 空的jQuery对象，因为Swift的下一个元素Scheme不符合条件[name=haskell] swift.prev(); // Python swift.prev('.dy'); // Python，因为Python同时符合过滤器条件.dy 过滤器（Filter） 过滤器一般不单独使用，它通常附加在选择器上，帮助我们更精确地定位元素。观察过滤器的效果： JavaScript Python Lua $('ul.lang li:first-child'); // 仅选出JavaScript $('ul.lang li:last-child'); // 仅选出Lua $('ul.lang li:nth-child(2)'); // 选出第N个元素，N从1开始 $('ul.lang li:nth-child(even)'); // 选出序号为偶数的元素 $('ul.lang li:nth-child(odd)'); // 选出序号为奇数的元素 过滤 和函数式编程的map、filter类似，jQuery对象也有类似的方法。 filter()方法可以过滤掉不符合选择器条件的节点： var langs = $('ul.lang li'); // 拿到JavaScript, Python, Swift, Scheme和Haskell var a = langs.filter('.dy'); // 拿到JavaScript, Python, Scheme 或者传入一个函数，要特别注意函数内部的this被绑定为DOM对象，不是jQuery对象： var langs = $('ul.lang li'); // 拿到JavaScript, Python, Swift, Scheme和Haskell langs.filter(function () { return this.innerHTML.indexOf('S') === 0; // 返回S开头的节点 }); // 拿到Swift, Scheme map()方法把一个jQuery对象包含的若干DOM节点转化为其他对象： var langs = $('ul.lang li'); // 拿到JavaScript, Python, Swift, Scheme和Haskell var arr = langs.map(function () { return this.innerHTML; }).get(); // 用get()拿到包含string的Array：['JavaScript', 'Python', 'Swift', 'Scheme', 'Haskell'] 此外，一个jQuery对象如果包含了不止一个DOM节点，first()、last()和slice()方法可以返回一个新的jQuery对象，把不需要的DOM节点去掉： var langs = $('ul.lang li'); // 拿到JavaScript, Python, Swift, Scheme和Haskell var js = langs.first(); // JavaScript，相当于$('ul.lang li:first-child') var haskell = langs.last(); // Haskell, 相当于$('ul.lang li:last-child') var sub = langs.slice(2, 4); // Swift, Scheme, 参数和数组的slice()方法一致 表单相关 针对表单元素，jQuery还有一组特殊的选择器： :input：可以选择，，和； :file：可以选择，和input[type=file]一样； :checkbox：可以选择复选框，和input[type=checkbox]一样； :radio：可以选择单选框，和input[type=radio]一样； :focus：可以选择当前输入焦点的元素，例如把光标放到一个上，用$('input:focus')就可以选出； :checked：选择当前勾上的单选框和复选框，用这个选择器可以立刻获得用户选择的项目，如$('input[type=radio]:checked')； :enabled：可以选择可以正常输入的、 等，也就是没有灰掉的输入； :disabled：和:enabled正好相反，选择那些不能输入的。 此外，jQuery还有很多有用的选择器，例如，选出可见的或隐藏的元素： $('div:visible'); // 所有可见的div $('div:hidden'); // 所有隐藏的div "},"Jquery/操作DOM.html":{"url":"Jquery/操作DOM.html","title":"操作DOM","keywords":"","body":"操作DOM jQuery的选择器很强大，用起来又简单又灵活，但是搞了这么久，我拿到了jQuery对象，到底要干什么？ 答案当然是操作对应的DOM节点啦！ 回顾一下修改DOM的CSS、文本、设置HTML有多么麻烦，而且有的浏览器只有innerHTML，有的浏览器支持innerText，有了jQuery对象，不需要考虑浏览器差异了，全部统一操作！ 注意,如果是从外部引入js文件，引入放在head跟放在body两个地方是不一样的，body的会进行对页面的初始化，但是head的不会,所以你将js在head处引入发现代码没有生效就是这个原因，head里有效的是触发。如果想要放在head初始化也有办法,在后面的事件会涉及。 修改Text和HTML jQuery对象的text()和html()方法分别获取节点的文本和原始HTML文本，例如，如下的HTML结构： JavaScript Java &amp; JavaScript 分别获取文本和HTML： $('#test-ul li[name=book]').text(); // 'Java & JavaScript' $('#test-ul li[name=book]').html(); // 'Java &amp; JavaScript' 一个jQuery对象可以包含0个或任意个DOM对象，它的方法实际上会作用在对应的每个DOM节点上。在上面的例子中试试： $('#test-ul li').text('JS'); // 是不是两个节点都变成了JS？ 所以jQuery对象的另一个好处是我们可以执行一个操作，作用在对应的一组DOM节点上。即使选择器没有返回任何DOM节点，调用jQuery对象的方法仍然不会报错： // 如果不存在id为not-exist的节点： $('#not-exist').text('Hello'); // 代码不报错，没有节点被设置为'Hello' 这意味着jQuery帮你免去了许多if语句。 修改CSS jQuery对象有“批量操作”的特点，这用于修改CSS实在是太方便了。考虑下面的HTML结构： JavaScript Java Python Swift Scheme 要高亮显示动态语言，调用jQuery对象的css('name', 'value')方法，我们用一行语句实现： $('#test-css li.dy>span').css('background-color', '#ffd351').css('color', 'red'); 注意，jQuery对象的所有方法都返回一个jQuery对象（可能是新的也可能是自身），这样我们可以进行链式调用，非常方便。 jQuery对象的css()方法可以这么用： var div = $('#test-div'); div.css('color'); // '#000033', 获取CSS属性 div.css('color', '#336699'); // 设置CSS属性 div.css('color', ''); // 清除CSS属性 为了和JavaScript保持一致，CSS属性可以用'background-color'和'backgroundColor'两种格式。 css()方法将作用于DOM节点的style属性，具有最高优先级。如果要修改class属性，可以用jQuery提供的下列方法： var div = $('#test-div'); div.hasClass('highlight'); // false， class是否包含highlight div.addClass('highlight'); // 添加highlight这个class div.removeClass('highlight'); // 删除highlight这个class 显示和隐藏DOM 要隐藏一个DOM，我们可以设置CSS的display属性为none，利用css()方法就可以实现。不过，要显示这个DOM就需要恢复原有的display属性，这就得先记下来原有的display属性到底是block还是inline还是别的值。 考虑到显示和隐藏DOM元素使用非常普遍，jQuery直接提供show()和hide()方法，我们不用关心它是如何修改display属性的，总之它能正常工作： var a = $('a[target=_blank]'); a.hide(); // 隐藏 a.show(); // 显示 注意，隐藏DOM节点并未改变DOM树的结构，它只影响DOM节点的显示。这和删除DOM节点是不同的。 获取DOM信息 利用jQuery对象的若干方法，我们直接可以获取DOM的高宽等信息，而无需针对不同浏览器编写特定代码： // 浏览器可视窗口大小: $(window).width(); // 800 $(window).height(); // 600 // HTML文档大小: $(document).width(); // 800 $(document).height(); // 3500 // 某个div的大小: var div = $('#test-div'); div.width(); // 600 div.height(); // 300 div.width(400); // 设置CSS属性 width: 400px，是否生效要看CSS是否有效 div.height('200px'); // 设置CSS属性 height: 200px，是否生效要看CSS是否有效 attr()和removeAttr()方法用于操作DOM节点的属性： // ... var div = $('#test-div'); div.attr('data'); // undefined, 属性不存在 div.attr('name'); // 'Test' div.attr('name', 'Hello'); // div的name属性变为'Hello' div.removeAttr('name'); // 删除name属性 div.attr('name'); // undefined prop()方法和attr()类似，但是HTML5规定有一种属性在DOM节点中可以没有值，只有出现与不出现两种，例如： 等价于： attr()和prop()对于属性checked处理有所不同： var radio = $('#test-radio'); radio.attr('checked'); // 'checked' radio.prop('checked'); // true prop()返回值更合理一些。不过，用is()方法判断更好： var radio = $('#test-radio'); radio.is(':checked'); // true prop()返回值更合理一些。不过，用is()方法判断更好. 类似的属性还有selected，处理时最好用is(':selected')。 操作表单 对于表单元素，jQuery对象统一提供val()方法获取和设置对应的value属性： /* Beijing Shanghai Shenzhen Hello */ var input = $('#test-input'), select = $('#test-select'), textarea = $('#test-textarea'); input.val(); // 'test' input.val('abc@example.com'); // 文本框的内容已变为abc@example.com select.val(); // 'BJ' select.val('SH'); // 选择框已变为Shanghai textarea.val(); // 'Hello' textarea.val('Hi'); // 文本区域已更新为'Hi' "},"Jquery/修改DOM结构.html":{"url":"Jquery/修改DOM结构.html","title":"修改DOM结构","keywords":"","body":"修改DOM结构 直接使用浏览器提供的API对DOM结构进行修改，不但代码复杂，而且要针对浏览器写不同的代码。 有了jQuery，我们就专注于操作jQuery对象本身，底层的DOM操作由jQuery完成就可以了，这样一来，修改DOM也大大简化了。 添加DOM 要添加新的DOM节点，除了通过jQuery的html()这种暴力方法外，还可以用append()方法，例如： JavaScript Python Swift 如何向列表新增一个语言？首先要拿到节点： var ul = $('#test-div>ul'); 然后，调用append()传入HTML片段： ul.append('Haskell'); 除了接受字符串，append()还可以传入原始的DOM对象，jQuery对象和函数对象： // 创建DOM对象: var ps = document.createElement('li'); ps.innerHTML = 'Pascal'; // 添加DOM对象: ul.append(ps); // 添加jQuery对象: ul.append($('#scheme')); // 添加函数对象: ul.append(function (index, html) { return 'Language - ' + index + ''; }); 添加函数对象，解释一下，index是指满足前面选择器的对象集合的index，html是该对象的内容。 传入函数时，要求返回一个字符串、DOM对象或者jQuery对象。因为jQuery的append()可能作用于一组DOM节点，只有传入函数才能针对每个DOM生成不同的子节点。 append()把DOM添加到最后，prepend()则把DOM添加到最前。 另外注意，如果要添加的DOM节点已经存在于HTML文档中，它会首先从文档移除，然后再添加，也就是说，用append()，你可以移动一个DOM节点。 如果要把新节点插入到指定位置，例如，JavaScript和Python之间，那么，可以先定位到JavaScript，然后用after()方法： var js = $('#test-div>ul>li:first-child'); js.after('Lua'); 也就是说，同级节点可以用after()或者before()方法。 删除节点 要删除DOM节点，拿到jQuery对象后直接调用remove()方法就可以了。如果jQuery对象包含若干DOM节点，实际上可以一次删除多个DOM节点： var li = $('#test-div>ul>li'); li.remove(); // 所有全被删除 "},"Jquery/事件.html":{"url":"Jquery/事件.html","title":"事件","keywords":"","body":"事件 因为JavaScript在浏览器中以单线程模式运行，页面加载后，一旦页面上所有的JavaScript代码被执行完后，就只能依赖触发事件来执行JavaScript代码。 浏览器在接收到用户的鼠标或键盘输入后，会自动在对应的DOM节点上触发相应的事件。如果该节点已经绑定了对应的JavaScript处理函数，该函数就会自动调用。 由于不同的浏览器绑定事件的代码都不太一样，所以用jQuery来写代码，就屏蔽了不同浏览器的差异，我们总是编写相同的代码。 举个例子，假设要在用户点击了超链接时弹出提示框，我们用jQuery这样绑定一个click事件： /* HTML: * * 点我试试 * */ // 获取超链接的jQuery对象: var a = $('#test-link'); a.on('click', function () { alert('Hello!'); }); on方法用来绑定一个事件，我们需要传入事件名称和对应的处理函数。 另一种更简化的写法是直接调用click()方法： a.click(function () { alert('Hello!'); }); 两者完全等价。我们通常用后面的写法。 鼠标事件 click: 鼠标单击时触发； dblclick：鼠标双击时触发； mouseenter：鼠标进入时触发； mouseleave：鼠标移出时触发； mousemove：鼠标在DOM内部移动时触发； hover：鼠标进入和退出时触发两个函数，相当于mouseenter加上mouseleave。 键盘事件 键盘事件仅作用在当前焦点的DOM上，通常是和。 keydown：键盘按下时触发； keyup：键盘松开时触发； keypress：按一次键后触发。 其他事件 focus：当DOM获得焦点时触发； blur：当DOM失去焦点时触发； change：当、或的内容改变时触发； submit：当提交时触发； ready：当页面被载入并且DOM树完成初始化后触发。 其中，ready仅作用于document对象。由于ready事件在DOM完成初始化后触发，且只触发一次，所以非常适合用来写其他的初始化代码。假设我们想给一个表单绑定submit事件，下面的代码没有预期的效果，这就是我们之前提过问题，在操作DOM里提过，因为放在head里的 js 不会初始化，所以没有生效。 // 代码有误: $('#testForm).on('submit', function () { alert('submit!'); }); ... 因为JavaScript在此执行的时候，尚未载入浏览器，所以$('#testForm)返回[]，并没有绑定事件到任何DOM上。 所以我们自己的初始化代码必须放到document对象的ready事件中，保证DOM已完成初始化： $(document).on('ready', function () { $('#testForm).on('submit', function () { alert('submit!'); }); }); ... 这样写就没有问题了。因为相关代码会在DOM树初始化后再执行。 由于ready事件使用非常普遍，所以可以这样简化： $(document).ready(function () { // on('submit', function)也可以简化: $('#testForm).submit(function () { alert('submit!'); }); }); 甚至还可以再简化为： $(function () { // init... }); 上面的这种写法最为常见。如果你遇到$(function () {...})的形式，牢记这是document对象的ready事件处理函数。 完全可以反复绑定事件处理函数，它们会依次执行： $(function () { console.log('init A...'); }); $(function () { console.log('init B...'); }); $(function () { console.log('init C...'); }); 事件参数 有些事件，如mousemove和keypress，我们需要获取鼠标位置和按键的值，否则监听这些事件就没什么意义了。所有事件都会传入Event对象作为参数，可以从Event对象上获取到更多的信息： $(function () { $('#testMouseMoveDiv').mousemove(function (e) { $('#testMouseMoveSpan').text('pageX = ' + e.pageX + ', pageY = ' + e.pageY); }); }); 取消绑定 一个已被绑定的事件可以解除绑定，通过off('click', function)实现: 你可能会遇到重复绑定一个点击事件，然后就会有冲突，所以可以现解绑然后再进行绑定。 function hello() { alert('hello!'); } a.click(hello); // 绑定事件 // 10秒钟后解除绑定: setTimeout(function () { a.off('click', hello); }, 10000); 这是因为两个匿名函数虽然长得一模一样，但是它们是两个不同的函数对象，off('click', function () {...})无法移除已绑定的第一个匿名函数。 为了实现移除效果，可以使用off('click')一次性移除已绑定的click事件的所有处理函数。 同理，无参数调用off()一次性移除已绑定的所有类型的事件处理函数。 事件触发条件 一个需要注意的问题是，事件的触发总是由用户操作引发的。例如，我们监控文本框的内容改动： var input = $('#test-input'); input.change(function () { console.log('changed...'); }); 当用户在文本框中输入时，就会触发change事件。但是，如果用JavaScript代码去改动文本框的值，将不会触发change事件： var input = $('#test-input'); input.val('change it!'); // 无法触发change事件 有些时候，我们希望用代码触发change事件，可以直接调用无参数的change()方法来触发该事件： var input = $('#test-input'); input.val('change it!'); input.change(); // 触发change事件 input.change()相当于input.trigger('change')，它是trigger()方法的简写。 为什么我们希望手动触发一个事件呢？如果不这么做，很多时候，我们就得写两份一模一样的代码。 "},"Jquery/动画.html":{"url":"Jquery/动画.html","title":"动画","keywords":"","body":"动画 用JavaScript实现动画，原理非常简单：我们只需要以固定的时间间隔（例如，0.1秒），每次把DOM元素的CSS样式修改一点（例如，高宽各增加10%），看起来就像动画了。 但是要用JavaScript手动实现动画效果，需要编写非常复杂的代码。如果想要把动画效果用函数封装起来便于复用，那考虑的事情就更多了。 使用jQuery实现动画，代码已经简单得不能再简化了：只需要一行代码！ 让我们先来看看jQuery内置的几种动画样式： 以下均能添加回调函数 show / hide 直接以无参数形式调用show()和hide()，会显示和隐藏DOM元素。但是，只要传递一个时间参数进去，就变成了动画： var div = $('#test-show-hide'); div.hide(3000); // 在3秒钟内逐渐消失 时间以毫秒为单位，但也可以是'slow'，'fast'这些字符串： var div = $('#test-show-hide'); div.show('slow'); // 在0.6秒钟内逐渐显示 toggle()方法则根据当前状态决定是show()还是hide()。 hide('slow') show('slow') toggle('slow') slideUp / slideDown 你可能已经看出来了，show()和hide()是从左上角逐渐展开或收缩的，而slideUp()和slideDown()则是在垂直方向逐渐展开或收缩的。 slideUp()把一个可见的DOM元素收起来，效果跟拉上窗帘似的，slideDown()相反，而slideToggle()则根据元素是否可见来决定下一步动作： var div = $('#test-slide'); div.slideUp(3000); // 在3秒钟内逐渐向上消失 slideUp('slow') slideDown('slow') slideToggle('slow') fadeIn / fadeOut fadeIn()和fadeOut()的动画效果是淡入淡出，也就是通过不断设置DOM元素的opacity属性来实现，而fadeToggle()则根据元素是否可见来决定下一步动作： var div = $('#test-fade'); div.fadeOut('slow'); // 在0.6秒内淡出 fadeOut('slow') fadeIn('slow') fadeToggle('slow') 自定义动画 如果上述动画效果还不能满足你的要求，那就祭出最后大招：animate()，它可以实现任意动画效果，我们需要传入的参数就是DOM元素最终的CSS状态和时间，jQuery在时间段内不断调整CSS直到达到我们设定的值： var div = $('#test-animate'); div.animate({ opacity: 0.25, width: '256px', height: '256px' }, 3000); // 在3秒钟内CSS过渡到设定值 animate()还可以再传入一个函数，当动画结束时，该函数将被调用： var div = $('#test-animate'); div.animate({ opacity: 0.25, width: '256px', height: '256px' }, 3000, function () { console.log('动画已结束'); // 恢复至初始状态: $(this).css('opacity', '1.0').css('width', '128px').css('height', '128px'); }); 实际上这个回调函数参数对于基本动画也是适用的。 有了animate()，你就可以实现各种自定义动画效果了： animate() 串行动画 jQuery的动画效果还可以串行执行，通过delay()方法还可以实现暂停，这样，我们可以实现更复杂的动画效果，而代码却相当简单： var div = $('#test-animates'); // 动画效果：slideDown - 暂停 - 放大 - 暂停 - 缩小 div.slideDown(2000) .delay(1000) .animate({ width: '256px', height: '256px' }, 2000) .delay(1000) .animate({ width: '128px', height: '128px' }, 2000); } 因为动画需要执行一段时间，所以jQuery必须不断返回新的Promise对象才能后续执行操作。简单地把动画封装在函数中是不够的。 animate 为什么有的动画没有效果 你可能会遇到，有的动画如slideUp()根本没有效果。这是因为jQuery动画的原理是逐渐改变CSS的值，如height从100px逐渐变为0。但是很多不是block性质的DOM元素，对它们设置height根本就不起作用，所以动画也就没有效果。 此外，jQuery也没有实现对background-color的动画效果，用animate()设置background-color也没有效果。这种情况下可以使用CSS3的transition实现动画效果。 "},"Jquery/AJAX.html":{"url":"Jquery/AJAX.html","title":"AJAX","keywords":"","body":"AJAX 用JavaScript写AJAX前面已经介绍过了，主要问题就是不同浏览器需要写不同代码，并且状态和错误处理写起来很麻烦。 用jQuery的相关对象来处理AJAX，不但不需要考虑浏览器问题，代码也能大大简化。 ajax jQuery在全局对象jQuery（也就是$）绑定了ajax()函数，可以处理AJAX请求。ajax(url, settings)函数需要接收一个URL和一个可选的settings对象，常用的选项如下： async：是否异步执行AJAX请求，默认为true，千万不要指定为false； method：发送的Method，缺省为'GET'，可指定为'POST'、'PUT'等； contentType：发送POST请求的格式，默认值为'application/x-www-form-urlencoded; charset=UTF-8'，也可以指定为text/plain、application/json； data：发送的数据，可以是字符串、数组或object。如果是GET请求，data将被转换成query附加到URL上，如果是POST请求，根据contentType把data序列化成合适的格式； headers：发送的额外的HTTP头，必须是一个object； dataType：接收的数据格式，可以指定为'html'、'xml'、'json'、'text'等，缺省情况下根据响应的Content-Type猜测。 其他选项详情w3c. 下面的例子发送一个GET请求，并返回一个JSON格式的数据： var jqxhr = $.ajax('/api/categories', { dataType: 'json' }); // 请求已经发送了 不过，如何用回调函数处理返回的数据和出错时的响应呢？ var jqxhr = $.ajax('/api/categories', { dataType: 'json' }).success(function (data) { ajaxLog('成功, 收到的数据: ' + JSON.stringify(data)); }).error(function (xhr, status) { ajaxLog('失败: ' + xhr.status + ', 原因: ' + status); }).complete(function () { ajaxLog('请求完成: 无论成功或失败都会调用'); }); 回调函数详情w3c。 安全限制 jQuery的AJAX完全封装的是JavaScript的AJAX操作，所以它的安全限制和前面讲的用JavaScript写AJAX完全一样。 如果需要使用JSONP，可以在ajax()中设置jsonp: 'callback'，让jQuery实现JSONP跨域加载数据。 关于跨域的设置请参考浏览器 - AJAX一节中CORS的设置。 "},"Jquery/扩展.html":{"url":"Jquery/扩展.html","title":"扩展","keywords":"","body":"扩展 当我们使用jQuery对象的方法时，由于jQuery对象可以操作一组DOM，而且支持链式操作，所以用起来非常方便。 但是jQuery内置的方法永远不可能满足所有的需求。比如，我们想要高亮显示某些DOM元素，用jQuery可以这么实现： $('span.hl').css('backgroundColor', '#fffceb').css('color', '#d85030'); $('p a.hl').css('backgroundColor', '#fffceb').css('color', '#d85030'); 总是写重复代码可不好，万一以后还要修改字体就更麻烦了，能不能统一起来，写个highlight()方法？ $('span.hl').highlight(); $('p a.hl').highlight(); 答案是肯定的。我们可以扩展jQuery来实现自定义方法。将来如果要修改高亮的逻辑，只需修改一处扩展代码。这种方式也称为编写jQuery插件。 编写jQuery插件 给jQuery对象绑定一个新方法是通过扩展$.fn对象实现的。让我们来编写第一个扩展——highlight1()： $.fn.highlight1 = function () { // this已绑定为当前jQuery对象: this.css('backgroundColor', '#fffceb').css('color', '#d85030'); return this; } 注意到函数内部的this在调用时被绑定为jQuery对象，所以函数内部代码可以正常调用所有jQuery对象的方法。 对于如下的HTML结构： 什么是jQuery jQuery是目前最流行的JavaScript库。 为什么最后要return this;？因为jQuery对象支持链式操作，我们自己写的扩展方法也要能继续链式下去： $('span.hl').highlight1().slideDown(); 不然，用户调用的时候，就不得不把上面的代码拆成两行。 但是这个版本并不完美。有的用户希望高亮的颜色能自己来指定，怎么办？ 我们可以给方法加个参数，让用户自己把参数用对象传进去。于是我们有了第二个版本的highlight2()： $.fn.highlight2 = function (options) { // 要考虑到各种情况: // options为undefined // options只有部分key var bgcolor = options && options.backgroundColor || '#fffceb'; var color = options && options.color || '#d85030'; this.css('backgroundColor', bgcolor).css('color', color); return this; } $('#test-highlight2 span').highlight2({ backgroundColor: '#00a8e6', color: '#ffffff' }); 对于默认值的处理，我们用了一个简单的&&和||短路操作符，总能得到一个有效的值。 另一种方法是使用jQuery提供的辅助方法$.extend(target, obj1, obj2, ...)，它把多个object对象的属性合并到第一个target对象中，遇到同名属性，总是使用靠后的对象的值，也就是越往后优先级越高： // 把默认值和用户传入的options合并到对象{}中并返回: var opts = $.extend({}, { backgroundColor: '#00a8e6', color: '#ffffff' }, options); 紧接着用户对highlight2()提出了意见：每次调用都需要传入自定义的设置，能不能让我自己设定一个缺省值，以后的调用统一使用无参数的highlight2()？ 也就是说，我们设定的默认值应该能允许用户修改。 那默认值放哪比较合适？放全局变量肯定不合适，最佳地点是$.fn.highlight2这个函数对象本身。 于是最终版的highlight()终于诞生了： $.fn.highlight = function (options) { // 合并默认值和用户设定值: var opts = $.extend({}, $.fn.highlight.defaults, options); this.css('backgroundColor', opts.backgroundColor).css('color', opts.color); return this; } // 设定默认值: $.fn.highlight.defaults = { color: '#d85030', backgroundColor: '#fff8de' } 这次用户终于满意了。 最终，我们得出编写一个jQuery插件的原则： 给$.fn绑定函数，实现插件的代码逻辑； 插件函数最后要return this;以支持链式调用； 插件函数要有默认值，绑定在$.fn..defaults上； 用户在调用时可传入设定值以便覆盖默认值。 针对特定元素的扩展 我们知道jQuery对象的有些方法只能作用在特定DOM元素上，比如submit()方法只能针对form。如果我们编写的扩展只能针对某些类型的DOM元素，应该怎么写？ 还记得jQuery的选择器支持filter()方法来过滤吗？我们可以借助这个方法来实现针对特定元素的扩展。 举个例子，现在我们要给所有指向外链的超链接加上跳转提示，怎么做？ 先写出用户调用的代码： $('#main a').external(); 然后按照上面的方法编写一个external扩展： $.fn.external = function () { // return返回的each()返回结果，支持链式调用: return this.filter('a').each(function () { // 注意: each()内部的回调函数的this绑定为DOM本身! var a = $(this); var url = a.attr('href'); if (url && (url.indexOf('http://')===0 || url.indexOf('https://')===0)) { a.attr('href', '#0') .removeAttr('target') .append(' ') .click(function () { if(confirm('你确定要前往' + url + '？')) { window.open(url); } }); } }); } "},"基础/异常处理.html":{"url":"基础/异常处理.html","title":"异常处理","keywords":"","body":"异常处理 高级语言通常都提供了更抽象的错误处理逻辑try ... catch ... finally，JavaScript也不例外。 try ... catch ... finally 使用try ... catch ... finally处理错误时，我们编写的代码如下： var r1, r2, s = null; try { r1 = s.length; // 此处应产生错误 r2 = 100; // 该语句不会执行 } catch (e) { console.log('出错了：' + e); } finally { console.log('finally'); } console.log('r1 = ' + r1); // r1应为undefined console.log('r2 = ' + r2); // r2应为undefined 错误类型 JavaScript有一个标准的Error对象表示错误，还有从Error派生的TypeError、ReferenceError等错误对象。我们在处理错误时，可以通过catch(e)捕获的变量e访问错误对象： try { ... } catch (e) { if (e instanceof TypeError) { alert('Type error!'); } else if (e instanceof Error) { alert(e.message); } else { alert('Error: ' + e); } } 使用变量e是一个习惯用法，也可以以其他变量名命名，如catch(ex)。 抛出错误 程序也可以主动抛出一个错误，让执行流程直接跳转到catch块。抛出错误使用throw语句。 var r, n, s; try { s = prompt('请输入一个数字'); n = parseInt(s); if (isNaN(n)) { throw new Error('输入错误'); } // 计算平方: r = n * n; console.log(n + ' * ' + n + ' = ' + r); } catch (e) { console.log('出错了：' + e); } 实际上，JavaScript允许抛出任意对象，包括数字、字符串。但是，最好还是抛出一个Error对象。 最后，当我们用catch捕获错误时，一定要编写错误处理语句： var n = 0, s; try { n = s.length; } catch (e) { console.log(e); } console.log(n); 哪怕仅仅把错误打印出来，也不要什么也不干： var n = 0, s; try { n = s.length; } catch (e) { } console.log(n); 因为catch到错误却什么都不执行，就不知道程序执行过程中到底有没有发生错误。 处理错误时，请不要简单粗暴地用alert()把错误显示给用户。教程的代码使用alert()是为了便于演示。 "}}